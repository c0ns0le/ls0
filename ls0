#!/usr/bin/env perl
# ls0: A "ls" replacement that null-terminates its output filenames.
# To see the output on the console, pipe it to cat -A.  Nulls show as ^@.

# Style note: Hungarian prefixes are used on scalars:
#   "hr" (hash ref), "lr" (list ref), "sr" (string ref), "nr" (numeric ref),
#   "b" or "is" (boolean), "s" (string), "wli" (Worklist_Item instance)

# TODO? add an option to prune specific directories?

package Com::DevWrench::Ls0;

# === Code ==============================================================
exit main();   # Invoke

# --- Syntax ---
use strict;
use warnings;

use constant { false => !!0, true  => !!1 };

# --- Imports ---
use Getopt::Long;
use Pod::Usage;
use File::Spec::Functions;
use File::Basename 'fileparse';
use File::stat;
use Fcntl ':mode';
#use File::Glob ':bsd_glob';
use Data::Dumper;
#use Class::Struct;

# --- Constants ---
use constant DEBUG => 1;

use constant {          # shell exit codes
    EXIT_OK => 0,          # success
    EXIT_FILE_ERR => 1,    # couldn't access at least one file
    EXIT_PARAM_ERR => 2,   # couldn't understand the command line
};

use constant {          # record terminators
    TERM_NULL => "\0",
    TERM_EOL => "\n",   # which will be translated to CRLF if necessary.
};                      # per http://www.perlmonks.org/?node_id=890769

# Regexes
use constant RE_DOT_OR_DOTDOT => qr/^\.{1,2}$/;

# --- Names of command-line arguments ---
use constant {  # *_GOPTS are additional parameters for Getopt::Long
    ALL_DOT => 'a',
    MOST_DOT => 'A',
    ESCAPE_OUTPUT => 'b', ESCAPE_OUTPUT_GOPTS => '|escape',
    DIR_AS_DIR => 'd',
    OUTPUT_SEPAR_IS_EOL => 'eol', OUTPUT_SEPAR_IS_EOL_GOPTS => '!',
    AT_FILE => 'from',          # file listing other inputs, NULL separated.
    AT_FILE_GOPTS => '|@=s@',   # Getopt options for AT_FILE
    AT_FILE_EOL => 'fromeol',   # file, EOL separated (platform-specific)
    AT_FILE_EOL_GOPTS => '=s@', # Getopt options
    DO_GLOB => 'glob',
    LEAVES_ONLY => 'leaf',
    SORT_OPT_REVERSE => 'r',
    RECURSE => 'R',
    RECURSIVE_GLOB => 'rglob',
    SORT_OPT_TIME => 't',           # Sort on some time (mtime by default)
    SORT_OPT_WHICHTIME => 'time',   # Which time to sort on
    SORT_OPT_WHICHTIME_GOPTS => '=s',
    SORT_OPT_NOSORT => 'U',
    LIKE_XARGS => "xargs",

    # Other options not specified on the command line, but included in the hash
    OUTPUT_SEPAR => 'output_separator',     # \n or \0
    DEPTH => 'depth',
    ONE_ARG => 'one_arg',       # if only one arg provided
    SORT => 'sort',             # how to sort
    SORTFIELD => 'sortfield',   # which field of the stat structure to sort on
    SORTDIR => 'sortdir',       # default order: 1 for asc; -1 for desc
    GLOBS => 'globs',           # list ref of the globs to check
    ADDL_PATHSPECS => 'fromatfiles',    # items listed in the atfiles
};

# Known environment variables
use constant {
    ENVVAR_ESCAPE => 'LS0_ESCAPE',
};

# Allowable sort types
use constant {
    SORT_BY_NONE => 'none',
    SORT_BY_NAME => 'name',     # a-z unless reverse.  Default.
    SORT_BY_TEXT => 'text',     # A textual sort on stat->$sortfield
    SORT_BY_NUM => 'num',       # Ditto, but numeric
    #SORT_BY_EXT => 'ext',       # extension
    #SORT_BY_TIME => 'time',     # newest first unless reverse
    #SORT_BY_SIZE => 'size',     # largest first unless reverse
    #SORT_BY_VER => 'ver',      # version within a filename.
        # Per https://www.gnu.org/software/coreutils/manual/html_node/Details-about-version-sort.html
        # TODO support this?  Require the user specify the filename encoding?
    # TODO atime, ctime
};

# Names of File::Stat fields we can sort on
use constant {
    SORTFIELD_ATIME => 'atime',
    SORTFIELD_CTIME => 'ctime',
    SORTFIELD_MTIME => 'mtime',
    # TODO add more
};

# --- Worklist Items ---
# What ls0 needs to do is defined by a worklist, a list of Worklist_Item refs.
# Each Worklist_Item includes text and various flags.

package Worklist_Item {
    use constant { false => 0, true  => 1 };    # constants are per-package
    use constant DEBUG => true;

    use fields qw(srtext top fromglob visible stat);
        # TODO later: use Class::Struct instead?

    sub new {   # ($self, $srText[, $bIsTop]) -> Worklist_Item
        my ($class, $srText, $isTop) = @_;

        my Worklist_Item $self = fields::new($class) unless ref $class;
        @$self{'top', 'fromglob', 'visible', 'stat'} =
            (false, false, true, undef);

        # Fill in from parameters
        $self->text($srText);
        if(defined $isTop) { $self->{top} = $isTop; }
        return $self;
    } #new()

    sub text {  # ($self[, $sText/srText]) -> string: setter if $sText provided
                # can take a string or a reference.
        my Worklist_Item $self = shift;
        if(@_) {
            my $arg = shift;
            if(ref($arg) eq "SCALAR") {
                $self->{srtext} = $arg;
            } else {
                $self->{srtext} = \$arg;
            }
        } #endif text provided
        return ${$self->{srtext}};  # always a getter
    } #text() setter/getter

    sub suppress {  # ($self) -> undef
        my Worklist_Item $self = shift;
        $self->{visible} = false;
    } #suppress() setter
} # Worklist_Item

# --- Forward declarations ---
sub process_worklist;
    # takes hrOpts, lrWorklist, lrOutputWorklist, and lrFailures.
    # Adds to lrOutputWorklist any outputs.  Adds to lrFailures any
    # string error messages.  May modify @$lrWorklist.
    # Returns a bool indicating whether at least one worklist item
    # is to be printed as a result.
sub process_worklist_item;
    # takes (hrOpts, wli, lrFailures, lrAddl [, bDontGlob].
    # Adds to lrAddl any pathspecs needing processing.  This yields a breadth-
    # first search of the space.  May modify $wli.
    # Returns a bool indicating whether the worklist item is visible.

sub sort_results;
    # takes hrOpts, lrWorklist; returns a reference to the sorted list.
    # Per the docs for sort, the result list includes aliases to the
    # elements of $lrWorklist, rather than copies.

sub parse_command_line_into;    # takes and modifies hrOpts; modifies @ARGV
sub read_entries;               # read entries from an atfile
sub make_worklist;              # takes lrStrings, bIsTop; returns lrWorklist.

# Utility routines
sub make_printable;     # Returns a printable representation of the arg string

# === Main ==============================================================
sub main {
    my %opts;           # everything that controls the behaviour of ls0
    my $lrWorklist;     # what we are being asked to process

    # since we are usually not printing newlines, don't line-buffer STDOUT
    $| = 1;

    #print STDERR ("cmdline=>",join("|",@ARGV),"\n") if DEBUG;
    parse_command_line_into \%opts;     # Modifies @ARGV.

    #print Dumper(%opts),"\n";

    # Set up for recursive glob: If it has been requested, stash the
    # provided pathspecs to try at each directory we visit.
    # We don't need to stash for non-recursive glob since the
    # patterns are already in @ARGV.
    $opts{&GLOBS} = @ARGV if $opts{&RECURSIVE_GLOB} && @ARGV;

    # Start with what was given on the command line (parse_c_l_into adds
    # '.' to @ARGV if no args were given, so @ARGV is always nonempty here).
    $lrWorklist = make_worklist \@ARGV, true;   # true => top-level args

    # Add the atfiles to the list
    if(@{$opts{&ADDL_PATHSPECS}}) {
        my $lrMoreWork = make_worklist $opts{&ADDL_PATHSPECS}, true;
        push @$lrWorklist, @$lrMoreWork;
    }

    # Do it, Rockapella!
    my @failures;   # which pathspecs we couldn't process
    if(process_worklist(\%opts,
                            $lrWorklist, $lrWorklist, \@failures)) {
                        #                ^^^^^^^^^^^ output
                        #   ^^^^^^^^^^^ input

        # Sort however the user wanted
        my $lrSortedWorklist = sort_results(\%opts, $lrWorklist);

        # Dump the (possibly escaped) results
        my $sep = $opts{&OUTPUT_SEPAR};
        my $esc = $opts{&ESCAPE_OUTPUT};

        #print STDERR "Before: " . Dumper($lrWorklist) . "\n" if DEBUG;
        #print STDERR "Sorted: " . Dumper($lrSortedWorklist) . "\n" if DEBUG;

        for my Worklist_Item $wli (@$lrSortedWorklist) {
            # skip ones we cleared
            next unless $wli->{visible};

            # escape if requested
            $wli->text(make_printable ($wli->text =~ s|^./||r)) if $esc;
                # like ls(1), don't start with "./"  ^^^^^^^^

            #print "=> " if DEBUG;
            print $wli->text, $sep;
        } # next $result
    } # endif any results

    # Report any errors
    if(@failures) {
        # Print all the errors, converting nonprintable characters to hex
        # escapes.  Errors are currently not sorted.
        print STDERR (
            join("\n", (map make_printable, @failures) ),
            "\n"
        );
        exit EXIT_FILE_ERR;
    } #endif @failures

    exit EXIT_OK;
} # main()

# === Worker routines ===================================================

sub process_worklist {
    my ($hrOpts, $lrProvidedWorklist, $lrOutputWorklist, $lrFailures,
        $subsid) = @_;

    my $bHaveVisibleResults = false;        # whether there's a result to print
    my $lrWorklist = $lrProvidedWorklist;   # changes as we run
    my @addl;   # this will hold paths to be processed next.
                # Using @addl means we don't have to mutate a possibly-long
                # $lrWorklist.

    my $done = false;
    while(!$done) {
        #print STDERR "**Iter (" . scalar @$lrWorklist . " items)\n" if DEBUG;
        @addl = ();     # always start fresh

        for my Worklist_Item $wli (@$lrWorklist) {
            my $vis =
                process_worklist_item($hrOpts, $wli, $lrFailures, \@addl);
            $bHaveVisibleResults ||= $vis;
                # Can't do $bHR ||= process_item() because ||= short-circuits
        } # foreach $path

        # If we are processing anything other than the output worklist,
        # tack the results onto that ever-growing list.  We do this in
        # case @ARGV is a long list from an xargs --- we don't want to
        # copy it, just in case.
        if($lrWorklist != $lrOutputWorklist) {
            #print STDERR "Adding ", scalar @$lrWorklist, " to ",
            #    scalar @$lrOutputWorklist, " entries.\n" if DEBUG;
            push @$lrOutputWorklist, @$lrWorklist;
        }

        # Set up for the next iteration
        $lrWorklist = make_worklist \@addl;
        $done = !@addl;
        #print STDERR "Made worklist of " . scalar @addl . " items\n" if DEBUG;

    } # while !$done

    return $bHaveVisibleResults;
} # process_worklist()

sub process_worklist_item {
    my ($hrOpts, $wli, $lrFailures, $lrAddl) = @_;

    # TODO implement globs
    #my $pathspec = $$srPathspec;
    #
    #if($hrOpts->{&DO_GLOB} && !bDontGlob) {
    #    my @results = bsd_glob($pathspec);
    #    if(!@results) {
    #        push @$lrFailures, "No files matched '" . make_printable $$srPathspec . "'.";
    #        return;
    #    } elsif(scalar @results > 1) {
    #        push @$lrAddl, @results;
    #       $$srPathspec=undef;     # Remove the glob (or something).
    #        return;                # Different for recursive glob.
    #    } else {
    #        $pathspec = $results[0];
    #            # If it was a single file, process it now.
    #            # TODO track whether pathspecs came from glob and don't
    #            # re-glob them?
    #    }
    #} # endif DO_GLOB

    # Process this worklist item, which represents a single directory entry

    my $item_text = $wli->text;
    my $fileinfo = stat($item_text);

    if(!$fileinfo) {
        push @$lrFailures, "Could not stat $item_text";
        $wli->suppress;     # dont' display it, since it's not actually there!
        return;
    }

    $wli->{stat} = $fileinfo;  # stash for use by the output code
    #print STDERR Dumper($wli->{stat}) if DEBUG;
    my ($basename, $dirs) = fileparse($item_text);
        # Don't use splitpath(), which chokes on '.git/.'.

    #print STDERR "Processing $item_text (basename  -$basename-, dir -$dirs-)\n"
    #    if DEBUG;

    # Shorthand for the context
    my $all_dot = $hrOpts->{&ALL_DOT};
    my $most_dot = $hrOpts->{&MOST_DOT};
    my $recursive = $hrOpts->{&RECURSE};
    my $dash_d = $hrOpts->{&DIR_AS_DIR};    # dash_d => not recursive
    my $isTop = $wli->{top};
        # "top-level" means it was specified on the command line.
    my $one_arg = $hrOpts->{&ONE_ARG};

    # Shorthand for special cases in the names
    my $isD = $basename eq '.';
    my $isDD = $basename eq '..';
    my $isDotfile = $basename =~ /^\./;

    my $isWanted = (    # dotfile-based filtering
        (!$isDotfile) ||                    # not a dotfile
        ($all_dot) ||                       # -a: keep dotfiles
        ($most_dot && !($isD || $isDD))     # -A: keep except . and ..
    );

    #print STDERR "  -a $all_dot  -A $most_dot  -d $dash_d  -R $recursive ".
    #    "top $isTop  one_arg $one_arg  . $isD  .. $isDD  .* $isDotfile\n"
    #    if DEBUG;

    if(S_ISDIR($fileinfo->mode)) {
        #print STDERR "  is directory\n" if DEBUG;

        # Figure out what to do

        my $bShouldSuppress = !$isWanted;   # by default, just list it as a
        my $bShouldDescend = false;         # regular entry (if we want it)

        # A top-level arg:
        #   Print it unless only one was given (e.g., for "ls ..")
        #   Descend unless -d.  -R is irrelevant because we descend by default.
        if( $isTop ) {
            $bShouldSuppress = $one_arg;
            $bShouldDescend = !$dash_d;
        }

        elsif( $isWanted ) {            # A non-toplevel we want: recurse
            $bShouldDescend =           # if requested, and not . or .. .
                $recursive && !($isD || $isDD);
        }   # Note -d trumps -R, so we don't have to test $dash_d.

        # --- Now that we've figured out what to do, go do it. ---
        if($bShouldSuppress) {
            #print STDERR "    suppressing\n" if DEBUG;
            $wli->suppress;
        }

        if($bShouldDescend) {
            #print STDERR "    recursing\n" if DEBUG;
            my $dirh;
            if(!opendir($dirh, $item_text)) {
                push @$lrFailures, "Could not read directory $item_text";
            } else {
                push @$lrAddl,
                    (map { my $rv = catfile $item_text, $_;
                            #print STDERR "    Added -$rv-\n" if DEBUG;
                            $rv } readdir($dirh));
                    # Also pushes . and .., which are ignored by the code above
                    # when we get to them in a later call.
            } #endif dir opened OK
        } # endif recursing

    } else {    # not a directory - treat files, pipes, links, &c. all as files
        #print STDERR "  is file\n" if DEBUG;
        if(!$isWanted) {        # Drop dotfiles unless requested
            #print STDERR "    suppressing\n" if DEBUG;
            $wli->suppress;
        }
    } #endif is a directory else

    return $wli->{visible};
} # process_worklist_item()

sub sort_results {  # ($hrOpts, $lrWorklist) -> $lrSortedWorklist
    my ($hrOpts, $lrWorklist) = @_;
    my @sorted;     # return array
    my $sort_type = $hrOpts->{&SORT};

    my $direction = $hrOpts->{&SORT_OPT_REVERSE} ? -1 : 1;
        # Invert the sense of the comparisons if requested
    $direction *= $hrOpts->{&SORTDIR};
        # Take into account the default order for this sort type

    #print STDERR "In: " . Dumper($lrWorklist) . "\n" if DEBUG;
    #print STDERR "Direction=" . $direction . ", sort=" . $hrOpts->{&SORT} .
    #    ".\n" if DEBUG;

    if($sort_type eq SORT_BY_NONE) {
        #print STDERR "Unsorted\n" if DEBUG;
        return $lrWorklist;     # *** EXIT POINT ***
    }

    # Sort
    if($sort_type eq SORT_BY_NAME) {
        #print STDERR "Name-sort\n" if DEBUG;
        @sorted = sort
            { $direction * ($a->text cmp $b->text) }
            @$lrWorklist;   # NOTE: sort on byte values, not characters.

    } elsif($sort_type eq SORT_BY_NUM) {
        my $fld = $hrOpts->{&SORTFIELD};
        #print STDERR "Numeric sort on ", $fld, "\n" if DEBUG;
        @sorted = sort
            { $direction * ($a->{stat}->$fld() <=> $b->{stat}->$fld()) }
            @$lrWorklist;   # NOTE: sort on byte values, not characters.

    } else {
        die "Unsupported sort type $sort_type\n";   # TODO
    }
    return \@sorted;
} # sort_results()

# === Utility routines ==================================================

sub make_printable {
# Return a printable version (octal escapes) of the original string.
    my $in = @_ ? $_[0] : $_;
    return $in =~ s/(\\|[^[:print:]])/'\\'.(sprintf "%03o", ord $1)/ger;
        # For hex, use s/.../'\x'.unpack('H*', $1)/ger per
        # http://perldoc.perl.org/perlpacktut.html#The-Basic-Principle
} # make_printable()

# === Command line ======================================================

sub parse_command_line_into {
# Takes a reference to a hash into which the options will go.
# Exits on failure or if help text was printed.
# Modifies @ARGV, since the input command line may well be a long list from
# xargs, and we don't want to make an expensive copy.

    my $hrOptsOut = shift;

    # --- Parse the options ---
    Getopt::Long::Configure 'gnu_getopt';

    # Set defaults so we don't have to test them with exists().
    %$hrOptsOut = ( &ALL_DOT => false );
    $hrOptsOut->{&ALL_DOT} = false;
    $hrOptsOut->{&MOST_DOT} = false;

    $hrOptsOut->{&ESCAPE_OUTPUT} =
        ( exists($ENV{&ENVVAR_ESCAPE}) && length($ENV{&ENVVAR_ESCAPE})>0 );
        # TODO? set default based on isatty(STDOUT)

    $hrOptsOut->{&DIR_AS_DIR} = false;
    #No default for OUTPUT_SEPAR_IS_EOL since it's negatable.
    $hrOptsOut->{&DO_GLOB} = false;
    $hrOptsOut->{&LEAVES_ONLY} = false;
    $hrOptsOut->{&SORT_OPT_REVERSE} = false;
    $hrOptsOut->{&RECURSE} = false;
    $hrOptsOut->{&SORT_OPT_TIME} = false;
    $hrOptsOut->{&SORT_OPT_WHICHTIME} = SORTFIELD_MTIME;
    $hrOptsOut->{&SORT_OPT_NOSORT} = false;
    $hrOptsOut->{&LIKE_XARGS} = false;

    # Get options
    GetOptions($hrOptsOut,  # destination hash
        'help|?', 'man',
        ALL_DOT,
        MOST_DOT,
        ESCAPE_OUTPUT . ESCAPE_OUTPUT_GOPTS,
        DIR_AS_DIR,
        OUTPUT_SEPAR_IS_EOL . OUTPUT_SEPAR_IS_EOL_GOPTS,
        AT_FILE . AT_FILE_GOPTS,
        AT_FILE_EOL . AT_FILE_EOL_GOPTS,
        DO_GLOB,
        LEAVES_ONLY,
        SORT_OPT_REVERSE,
        RECURSE,
        SORT_OPT_TIME,
        SORT_OPT_WHICHTIME . SORT_OPT_WHICHTIME_GOPTS,
        SORT_OPT_NOSORT,
        LIKE_XARGS,
        )
    or pod2usage(2);

    # Help, if requested
    pod2usage(1) if defined $hrOptsOut->{help};
    pod2usage(-verbose => 2) if defined $hrOptsOut->{man};

    # --- Process implied options. ---
    # Note: have to use ampersand on &RECURSIVE_GLOB per
    # http://stackoverflow.com/a/96869/2877364 by
    # http://stackoverflow.com/users/3101/nohat

    # -d overrides -R
    if($hrOptsOut->{&DIR_AS_DIR}) {
        $hrOptsOut->{&RECURSE} = false;
    }

    # --rglob implies -R and --glob
    if($hrOptsOut->{&RECURSIVE_GLOB}) {
        if(!$hrOptsOut->{&DIR_AS_DIR}) {
            $hrOptsOut->{&RECURSE} = true;
            $hrOptsOut->{&DO_GLOB} = true;
        } else {
            print STDERR "Can't use --rglob and -d together\n";
            exit EXIT_PARAM_ERR;
        }
    } #endif --rglob

    # --xargs implies "--from -"
    if($hrOptsOut->{&LIKE_XARGS}) {
        if(exists($hrOptsOut->{&AT_FILE})) {
            push(@{$hrOptsOut->{&AT_FILE}}, "-")
        } else {
            $hrOptsOut->{&AT_FILE} = ["-"];
        }
    }

    # --- Sorting options ---
    # TODO expand to support other sorts

    # Sanity checks.  First, -U prohibits all other sorting options.
    if($hrOptsOut->{&SORT_OPT_NOSORT} && (
            $hrOptsOut->{&SORT_OPT_REVERSE} ||
            $hrOptsOut->{&SORT_OPT_TIME}
    )) {
        print STDERR "Can't use -U with any other sort option\n";
        exit EXIT_PARAM_ERR;
    }

    if($hrOptsOut->{&SORT_OPT_NOSORT}) {
        $hrOptsOut->{&SORT} = SORT_BY_NONE;

    } elsif($hrOptsOut->{&SORT_OPT_TIME}) {
        $hrOptsOut->{&SORT} = SORT_BY_NUM;
        $hrOptsOut->{&SORTDIR} = -1;    # descending by default

        my %time_types = (      # Possible ways to sort by time.
            atime => SORTFIELD_ATIME,   # ls(1) gives lots of synonyms.
            access => SORTFIELD_ATIME,
            use => SORTFIELD_ATIME,
            ctime => SORTFIELD_CTIME,
            status => SORTFIELD_CTIME,
            mtime => SORTFIELD_MTIME,   # a few others
            change => SORTFIELD_MTIME,
        );

        my $which = $hrOptsOut->{&SORT_OPT_WHICHTIME};
        if(!exists $time_types{$which}) {
            print STDERR "Unknown time type --time=$which\n",
                "Valid values are: ",
                join(", ", sort keys %time_types), ".\n";
            exit EXIT_PARAM_ERR;
        }
        $hrOptsOut->{&SORTFIELD} =
            $time_types{$hrOptsOut->{&SORT_OPT_WHICHTIME}}

    } else {    # default sort
        $hrOptsOut->{&SORT} = SORT_BY_NAME;
        $hrOptsOut->{&SORTDIR} = 1;     # ascending by default
    }

    # --- Set other internal values based on the provided options ---

    # Output separator
    $hrOptsOut->{&OUTPUT_SEPAR} = TERM_NULL;     # by default

    $hrOptsOut->{&OUTPUT_SEPAR} = TERM_EOL       # if implied or requested
        if ($hrOptsOut->{&ESCAPE_OUTPUT} || $hrOptsOut->{&OUTPUT_SEPAR_IS_EOL});

    $hrOptsOut->{&OUTPUT_SEPAR} = TERM_NULL      # but --noeol always wins
        if (defined $hrOptsOut->{&OUTPUT_SEPAR_IS_EOL} &&
            !$hrOptsOut->{&OUTPUT_SEPAR_IS_EOL}) ;

    # How many args?  This is a special case: don't print the arg name
    # if it was the only arg and was a directory.
    $hrOptsOut->{&ONE_ARG} = (scalar @ARGV == 1);

    # Globbing
    if($hrOptsOut->{&RECURSIVE_GLOB} || $hrOptsOut->{&DO_GLOB}) {
        print STDERR "Globbing not yet implemented.\n";     # DEBUG
        exit EXIT_PARAM_ERR;
    }

    # --- at-files ---

    # Check for duplicates
    {
        my @filenames = (   # all the filenames together
            exists($hrOptsOut->{&AT_FILE}) ? @{$hrOptsOut->{&AT_FILE}} : (),
            exists($hrOptsOut->{&AT_FILE_EOL}) ?
                    @{$hrOptsOut->{&AT_FILE_EOL}} : ()
        );
        my %seen;   # which filenames we've seen
        my $ok = true;

        for my $fn (@filenames) {
            if(exists $seen{$fn}) {
                print STDERR "Filename ", make_printable($fn),
                        " listed more than once.\n";
                $ok = false;
            }
            $seen{$fn}=true;
        } # foreach $fn

        if(!$ok) {
            exit EXIT_PARAM_ERR;
        }
    } #end duplicate-check

    my @entries;    # list of all the pathspecs in the atfiles

    if(exists $hrOptsOut->{&AT_FILE}) {
        #print STDERR "Have atfiles\n" if DEBUG;
        #print STDERR $hrOptsOut->{&AT_FILE}, "\n";
        #print STDERR Dumper(\($hrOptsOut->{&AT_FILE})), "\n";
        my $lrEntries = read_entries(TERM_NULL, $hrOptsOut->{&AT_FILE});
        push @entries, @$lrEntries;
    } # endif --from

    if(exists $hrOptsOut->{&AT_FILE_EOL}) {
        #print STDERR "Have eol atfiles\n" if DEBUG;
        my $lrEntries = read_entries(TERM_EOL, $hrOptsOut->{&AT_FILE_EOL});
        push @entries, @$lrEntries;
    } # endif --fromeol

    #print STDERR "Entries:\n", Dumper(@entries), "\n" if DEBUG;
    $hrOptsOut->{&ADDL_PATHSPECS} = \@entries;

    # DEBUG
    if($hrOptsOut->{&LEAVES_ONLY}) {
        print STDERR "--leaf not yet implemented.\n";     # DEBUG
        exit EXIT_PARAM_ERR;
    }

    # --- If we have no args or atfiles, process the current dir. ---
    if(!@ARGV && !@entries) {
        push @ARGV, curdir();
    }

    #print STDERR ("pathspecs=>",join("\n",@ARGV),"\n") if DEBUG;

} # parse_command_line_into()

sub read_entries {
# takes $sTerm and $lrFilenames; returns $lrEntries.
    #print STDERR Dumper(@_), "\n";
    my ($sTerm, $lrFilenames) = @_;
    #print STDERR Dumper(@$lrFilenames), "\n";
    my @retval;

    for my $fn (@$lrFilenames) {
        #print STDERR "$fn\n";
        my $fh;
        if($fn eq "-") {    # we already checked that this only
            #print STDERR "Using stdin\n";
            $fh = *STDIN;    # occurs once.
        }
        elsif(! (-f $fn && -r _ && -s _)) {
            print STDERR (  # E.g., if someone says -@ <dirname>
                "Filename ", make_printable($fn),
                " isn't something I can read names from.\n"
            );
            exit EXIT_PARAM_ERR;
        }
        elsif(!open($fh, "<:raw", $fn)) {
            print STDERR    # raw because NULL term
                "Couldn't open filename ", make_printable $fn, "\n";
            exit EXIT_PARAM_ERR;
        }

        local $/;   # Use file-slurp because split() trims trailing separators,
                    # which <$fh> with $/==$sTerm does not.
        my $file_contents = <$fh>;

        push(@retval, split($sTerm, $file_contents));
    } #foreach filename

    return \@retval;
} # read_entries()

sub make_worklist {
    my $lrStrings = shift;  # May be a reference to an empty list
    my $isTop = @_ ? shift : false;
    my @srStringRefs = \(@$lrStrings);
        # list of string refs to each element of the provided list

    my @worklist = map { Worklist_Item::->new($_, $isTop) } @srStringRefs;

    return \@worklist;
} # make_worklist()

############################################################################
# Usage manual is below

__END__

=pod

=encoding UTF-8

=head1 NAME

ls0 - List filenames, with each output null-terminated.

=head1 SYNOPSIS

ls0 [options] [--] [pathspecs]

(Run ls0 --help for options, or ls0 --man for full documentation)

=head1 OPTIONS

=over

=item B<-a>

Also list files beginning with a '.'

=item B<-A>

Also list files beginning with a '.', except for '.' and '..'

=item B<-b>, B<--escape>

Print octal escapes for special characters and backslashes.  Implies B<--eol>
(newline separators); also specify B<--noeol> if you still want null
terminators.  Can be used as default by setting environment variable
C<LS0_ESCAPE> (see below).

=item B<-d>

List directories as directories; don't list their contents.  Overrides B<-R>.
Can't be used with B<--rglob>.

=item B<--eol> (disable with B<--noeol>)

Separate output entries with a platform-specific end-of-line sequence
rather than a NULL.  May be useful with B<-b> or B<--glob>.

=item B<< --from <argfile> >> (or B<< -@ <argfile> >>)

Read the pathspecs to be processed from B<argfile>; specify "-" to read from
standard input.  Each pathspec in B<argfile>should
be separated by a NULL terminator ('\0').  This is ls_0_, after all.
The input is read in binary mode, so filenames can contain any non-NULL
character.

See L</"Reading argfiles"> for details.

=item B<< --fromeol <argfile> >>

As B<--from>, but each pathspec in B<argfile>
should be separated by a platform-specific end-of-line.

See L</"Reading argfiles"> for details.

=item B<--glob>

Expand the provided pathspecs using perl's File::Glob::bsd_glob.
This is provided for shells that don't glob, or don't glob as you expect.
Make sure to quote the arguments if necessary to prevent your shell from
globbing before ls0 sees them.

=item B<--leaf>

Only list leaves, i.e., files plus directories for which no lower-level files
are being listed.

=item B<--noescape>

Don't escape.  Used to override the effect of environment variable
C<LS0_ESCAPE>.  Not yet implemented.

=item B<-r>

Reverse the order of the sort.

=item B<-R>

Visit subdirectories recursively.  No effect if B<-d> is specified.

=item B<--rglob>

Glob in ls0 rather than (or in addition to) in the shell.  Try to glob
the pathspecs given on the command line in each directory visited.
Implies B<-R> and B<--glob>.  Can't be used with B<-d>.

=item B<-t>

Sort by time, newest first (unless B<-r>).  Uses the modification time
unless B<--time> is given.

=item B<< --time <timeval> >>

Use B<< <timeval> >> as the time when sorting.  Run C<ls0 --time=> to see
the list of available times.  At least B<atime>, B<ctime>, and B<mtime>
are available.

=item B<-U>

Don't sort the results - you get them in whatever order you get them.
This will likely be the breadth-first search order ls0 currently uses,
but you B<shall not> make any assumptions about name order when using
this option.

=item B<--xargs>

A convenient synonym for C<--from ->.  For example, instead of
C<find ... | xargs ls>, you can use C<find ... -print0 | ls0 --xargs>
to get the same effect with the benefits of (1) the safety NULL terminators
provide, and (2) support for a higher match count than the command line
can handle.

=back

=head2 Environment variables

=over

=item C<LS0_ESCAPE>

When set to a nonempty value, ls0 will escape (-b) by default.  Override with
B<--noescape>, once that's implemented.

=back

=head2 Reading argfiles

The B<--from> and B<--fromeol> options read argfiles and treat entries in those
files as if those entries had been specified on the command line.  Things to
bear in mind:

=over

=item *

The filename C<-> refers to standard input.

=item *

You can't specify the same B<argfile> for more than one
B<--from> or B<--fromeol> option.

=item *

You B<shall not> make any assumptions about the relative order of items
listed on the command line or in argfiles.  In any case, the output order is
controlled only by any sorting options you provide.

=item *
B<--fromeol> does not unescape any
characters.  If you use this, make sure the filenames in B<argfile> don't
contain end-of-line characters.

=item *
B<--fromeol> uses the platform-specific newline sequence, e.g.,
C<\r>, C<\n>, or C<\r\n>.  If you try to read
DOS text files on a UNIX ls0, the input entries will have extra "\r"
characters at the end of them.

=back

=head1 DIFFERENCES BETWEEN GNU ls(1) and ls0(1)

=head2 New Features

=over

=item B<< --from <argfile> >>, B<< --fromeol <argfile> >>

Read input pathspecs from B<argfile>

=item B<--glob>

Glob in ls0 rather than (or in addition to) in the shell

=item B<--rglob>

Glob in ls0 rather than (or in addition to) in the shell, and glob in each
subdir

=item B<--leaf>

Only list leaves.

=back

=head2 Unsupported ls(1) Features

The following GNU ls(1) options are not supported by ls0:

=over

=item B<-1> (print single line), B<-C> (list down columns), B<-m> (comma-separated output), B<-x> (list across rows), B<--format>

We don't print these formats; we only support NULL and EOL as delimiters,
and don't do multicolumn.
Our B<-b> implies one line per file.

=item B<-F>/B<--file-type> (print indicators), B<-N>/B<--literal> (print names literally), B<-q> (hide control chars), B<-Q>/B<--quote-name> (quote output), B<--quoting-style>

We only print raw or with backslash escapes (B<-b>), so we don't support these.

=item B<--color>

Nope.  Sorry!

=item B<-D>

Long live vi!

=back

=head2 Differences in behaviour

=head3 Default search order

ls(1) sorts case-insensitively by default, e.g., C<alpha, BAR, foo, QUUX>.
We sort on byte values without regard to case or encoding, e.g. (in ASCII),
C<BAR, QUUX, alpha, foo>.

=head3 Output format for multiple subdirectories

When listing multiple directories, e.g., C<ls foo/ bar/>, ls(1) shows:

    foo:
    file_in_foo

    bar:
    file_in_bar

However, ls0(1) is intended for machine output, so it produces:

    foo
    foo/file_in_foo
    bar
    bar/file_in_bar

in whatever order you have specified by the sort options.  With B<-U>, for
example, you may get:

    foo
    bar
    foo/file_in_foo
    bar/file_in_bar

(the breadth-first order), although you may get a different order.

=head1 COPYRIGHT

Copyright (c) 2016 Chris White L<http://www.devwrench.com>
CC-BY-SA 3.0

Inspired by L<https://stackoverflow.com/a/41168189/2877364> by
myself, L<cxw|https://stackoverflow.com/users/2877364/cxw>.
Code based in part on L<http://stackoverflow.com/a/13999717/2877364> by
L<turningtaxis|http://stackoverflow.com/users/1922919/turningtaxis>
and on L<http://stackoverflow.com/a/3960071/2877364> by
L<ruel|http://stackoverflow.com/users/459338/ruel>.

=cut

# vi: set ts=4 sts=4 sw=4 et ai ff=unix fenc=utf8: #

