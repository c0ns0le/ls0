#!/usr/bin/env perl
# ls0: A "ls" replacement that null-terminates its output filenames.
# To see the output on the console, pipe it to cat -A.  Nulls show as ^@.

# Style note: "hr" (hash ref), "lr" (list ref), "sr" (string ref),
# "nr" (numeric ref) Hungarian prefixes are used on scalars.

# === Code ==============================================================
exit main(@ARGV);   # Invoke

# --- Syntax ---
use strict;
use warnings;

use constant false => 0;
use constant true  => 1;

# --- Imports ---
use Getopt::Long;
use Pod::Usage;
use File::Glob ':bsd_glob';

# --- Constants ---
use constant DEBUG => 1;

use constant {
    EXIT_OK => 0,          # success
    EXIT_FILE_ERR => 1,    # couldn't access at least one file
    EXIT_PARAM_ERR => 2,   # couldn't understand the command line
};

# --- Names of command-line arguments ---
use constant {  # *_GOPTS are additional parameters for Getopt::Long
    ALL_DOT => 'a',
    MOST_DOT => 'A',
    ESCAPE_OUTPUT => 'b', ESCAPE_OUTPUT_GOPTS => '|escape',
    DIR_AS_DIR => 'd',
    OUTPUT_SEPAR_IS_EOL => 'eol',
    AT_FILE => 'from',          # file listing other inputs, NULL separated.
    AT_FILE_GOPTS => '=s@',     # Getopt options for AT_FILE
    AT_FILE_NL => 'fromeol',    # file, EOL separated (platform-specific)
    AT_FILE_NL_GOPTS => '=s@',  # Getopt options
    DO_GLOB => 'glob',

    # Other options not specified on the command line, but included in the hash
    OUTPUT_SEPAR => 'output_separator',     # \n or \0
};

# --- Forward declarations ---
sub parse_command_line_into;    #takes and modifies hrOptions
sub process_pathspecs;
    # takes hrOptions, lrPathspecs, and lrFailures.
    # Returns true if all pathspecs were found.  Otherwise, fills in lrFailures
    # with the pathspecs that failed and returns false.
sub make_printable;     # Returns a printable representation of the arg string

# === Main ==============================================================
sub main {
    my %opts;
    print STDERR ("cmdline=>",join("|",@ARGV),"\n") if DEBUG;
    parse_command_line_into \%opts;     # Modifies @ARGV.
    #DEBUG
    #print %opts;
    #print "\n";
    #print @ARGV;
    #print "\n";
    #print "foo\0bar\0";

    my @failures;   # which pathspecs we couldn't process
    my $success=process_pathspecs(\%opts, \@ARGV, \@failures);

    if(!$success) {
        print STDERR ("failures=>",join("|",@failures),"\n") if DEBUG;
        # Print all the errors, converting nonprintable characters to hex
        # escapes.
        print STDERR "Could not process the following pathspecs:\n";
        print STDERR (
            join("\n", (map make_printable, @failures) ),
            "\n"
        );
        exit EXIT_FILE_ERR;
    } #endif !$success

} # main()

# === Worker routines ===================================================

sub process_pathspecs {
    my ($hrOpts, $lrPaths, $lrFailures) = @_;
        #http://stackoverflow.com/q/8831278/2877364
    my @addl;   # this will hold paths to be processed next.
                # Using @addl means we don't have to mutate a possibly-long
                # @ARGV.

    for my $path (@$lrPaths) {
        print STDERR "Saw $path\n" if DEBUG;
        push @{$lrFailures}, $path; # DEBUG
    } # foreach $path

    if(@addl) {
        @_=($hrOpts, \@addl, $lrFailures);
        goto &process_pathspecs;    # tail recurse to process @addl
    }

    return !@{$lrFailures};   # Succeeded if lrFailures is empty.
} # process_pathspecs()

sub make_printable {
# Return a printable version (currently octal escapes) of the original string.
# TODO change this from hex escapes to cat -v format.
    return s/(\\|[^[:print:]])/'\\'.(sprintf "%03o", ord $1)/ger;
        # For hex, use s/.../'\x'.unpack('H*', $1)/ger per 
        # http://perldoc.perl.org/perlpacktut.html#The-Basic-Principle
} # make_printable()

# === Command line ======================================================

sub parse_command_line_into {
# Takes a reference to a hash into which the options will go.
# Exits on failure or if help text was printed.
# Modifies @ARGV, since the input command line may well be a long list from
# xargs, and we don't want to make an expensive copy.

    my $hrOptsOut = shift;

    Getopt::Long::Configure qw(gnu_getopt);

    GetOptions($hrOptsOut,  # destination hash
        'help|?', 'man',
        ALL_DOT, 
        MOST_DOT, 
        ESCAPE_OUTPUT . ESCAPE_OUTPUT_GOPTS,
        DIR_AS_DIR,
        OUTPUT_SEPAR_IS_EOL,
        AT_FILE . AT_FILE_GOPTS,
        AT_FILE_NL . AT_FILE_NL_GOPTS,
        DO_GLOB,
        )
    or pod2usage(2);

    # Help, if requested
    pod2usage(1) if defined $hrOptsOut->{help};
    pod2usage(-verbose => 2) if defined $hrOptsOut->{man};

    if(!@ARGV) {     # If we have no args, process the current dir
        push @ARGV, '.';
    }

    print STDERR ("pathspecs=>",join("\n",@ARGV),"\n") if DEBUG;

    # Set the output format and separator based on the provided options

} # parse_command_line_into()

__END__

# Usage
=head1 NAME

ls0 - List filenames, with each output null-terminated.

=head1 SYNOPSIS

ls0 [options] [--] [pathspecs]

=head1 OPTIONS

=over 4

=item B<-a>

Also list files beginning with a '.'

=item B<-A>

Also list files beginning with a '.', except for '.' and '..'

=item B<-b>, B<--escape>

Print octal escapes for special characters and backslashes.

=item B<-d>

List directories as directories; don't list their contents

=item B<--eol>

Separate output entries with a platform-specific end-of-line sequence
rather than a NULL.  Not sure why you would want this, but it's easy to add
just in case!  You could productively use this with B<--glob>, I suppose.

=item B<< --from <argfile> >>, B<< --fromeol <argfile> >>

Read the pathspecs to be processed from B<argfile>.  Each pathspec should
be separated by a NULL terminator ('\0').  This is ls_0_, after all.

=item B<< --fromeol <argfile> >>

Read the pathspecs to be processed from B<argfile>.  Each pathspec should
be separated by a platform-specific end-of-line (C<\r>, C<\n>, or C<\r\n>).
If you use this, make sure B<argfile> doesn't list any filenames that include
end-of-lines.

=item B<--glob>

Expand the provided pathspecs using perl's File::Glob::bsd_glob.
This is provided for shells that don't glob, or don't glob as you expect.
Make sure to quote the arguments if necessary to prevent your shell from
globbing before ls0 sees them.

=back

=head1 DIFFERENCES BETWEEN GNU ls(1) and ls0(1)

=head2 New Features

=over 4

=item B<< --from <argfile> >>, B<< --fromeol <argfile> >>

Read input pathspecs from B<argfile>

=item B<--glob>

Glob in ls0 rather than (or in addition to) in the shell

=back

=head2 Unsupported ls(1) Features

The following GNU ls(1) options are not supported by ls0:

=over 4

=item B<-1> (print single line)

No need for it; we're not printing lines.

=back

=head1 COPYRIGHT

Copyright (c) 2016 Chris White <http://www.devwrench.com>
CC-BY-SA 3.0

Inspired by https://stackoverflow.com/a/41168189/2877364 by
myself, https://stackoverflow.com/users/2877364/cxw .
Code based in part on http://stackoverflow.com/a/13999717/2877364 by
http://stackoverflow.com/users/1922919/turningtaxis
and on http://stackoverflow.com/a/3960071/2877364 by
http://stackoverflow.com/users/459338/ruel

=cut

# vi: set ts=4 sts=4 sw=4 et ai ff=unix fenc=utf8: #

