#!/usr/bin/env perl
# ls0: A "ls" replacement that null-terminates its output filenames.
# To see the output on the console, pipe it to cat -A.  Nulls show as ^@.

# Style note: Hungarian prefixes are used on scalars:
#   "hr" (hash ref), "lr" (list ref), "sr" (string ref), "nr" (numeric ref),
#   "b" or "is" (boolean), "s" (string)

# TODO? add an option to prune specific directories?
# TODO store more info with each path: name, BFS pass # or depth,
# whether glob result or not.

package Com::DevWrench::Ls0;

# === Code ==============================================================
exit main();   # Invoke

# --- Syntax ---
use strict;
use warnings;

use constant false => 0;
use constant true  => 1;

# --- Imports ---
use Getopt::Long;
use Pod::Usage;
use File::Spec::Functions;
use File::Basename;
use File::stat;
use Fcntl ':mode';
#use File::Glob ':bsd_glob';

# --- Constants ---
use constant DEBUG => 1;

use constant {          # shell exit codes
    EXIT_OK => 0,          # success
    EXIT_FILE_ERR => 1,    # couldn't access at least one file
    EXIT_PARAM_ERR => 2,   # couldn't understand the command line
};

use constant {          # record terminators
    TERM_NULL => "\0",
    TERM_EOL => "\n",   # which will be translated to CRLF if necessary.
};                      # per http://www.perlmonks.org/?node_id=890769

# Regexes
use constant RE_DOT_OR_DOTDOT => qr/^\.{1,2}$/;

# --- Names of command-line arguments ---
use constant {  # *_GOPTS are additional parameters for Getopt::Long
    ALL_DOT => 'a',
    MOST_DOT => 'A',
    ESCAPE_OUTPUT => 'b', ESCAPE_OUTPUT_GOPTS => '|escape',
    DIR_AS_DIR => 'd',
    OUTPUT_SEPAR_IS_EOL => 'eol', OUTPUT_SEPAR_IS_EOL_GOPTS => '!',
    AT_FILE => 'from',          # file listing other inputs, NULL separated.
    AT_FILE_GOPTS => '|@=s@',   # Getopt options for AT_FILE
    AT_FILE_NL => 'fromeol',    # file, EOL separated (platform-specific)
    AT_FILE_NL_GOPTS => '=s@',  # Getopt options
    DO_GLOB => 'glob',
    RECURSE => 'R',
    RECURSIVE_GLOB => 'rglob',

    # Other options not specified on the command line, but included in the hash
    OUTPUT_SEPAR => 'output_separator',     # \n or \0
    DEPTH => 'depth',
    ONE_ARG => 'one_arg',       # if only one arg provided
};

# TODO RESUME HERE distinguish possibly globbable paths from the results of
# globs, which should not be re-globbed.
# TODO maybe carry the stat structure along with each pathspec?

# --- Worklists ---
# What ls0 needs to do is defined by a worklist, a list of hash refs.
# Each hash includes text and various flags.
sub wl_new; # takes text reference[, hash of flags] and returns a hash ref.
sub wl_suppress;    # takes hrWorklistItem; sets not to display.

use constant {  # worklist-item fields
    WL_TEXT_REF => 'text',  # text of the reference
    WL_IS_TOP => 'is_top',  # whether the item is from the command line
    WL_IS_GLOB_RESULT => 'is_glob_result',  # whether the item is from glob
                                            # (so don't re-glob it)
    WL_DO_NOT_PRINT => 'suppress',      # if true, don't show as a result
    WL_STAT_REF => 'stat',          # File::stat structure
};

# --- Forward declarations ---
sub process_worklist;
    # takes hrOpts, lrGlobs, lrWorklist, lrOutputWorklist, and lrFailures.
    # Adds to lrOutputWorklist any outputs.  Adds to lrFailures any
    # string error messages.  May modify @$lrWorklist.
    # Returns a bool indicating whether at least one worklist item
    # is to be printed as a result.
sub process_worklist_item;
    # takes (hrOpts, lrGlobs, hrWorklistItem, lrFailures, lrAddl [, bDontGlob].
    # Adds to lrAddl any pathspecs needing processing.  This yields a breadth-
    # first search of the space.  May modify %$hrWorklistItem.
    # Returns a bool indicating whether the worklist item is to be printed.

sub sort_results;
    # takes hrOpts, lrWorklist

sub parse_command_line_into;    # takes and modifies hrOpts; modifies @ARGV
sub make_worklist;              # takes lrStrings, bIsTop; returns lrWorklist.

# Utility routines
sub make_printable;     # Returns a printable representation of the arg string

# === Main ==============================================================
sub main {
    my %opts;           # everything that controls the behaviour of ls0
    my $lrWorklist;     # what we are being asked to process

    #print STDERR ("cmdline=>",join("|",@ARGV),"\n") if DEBUG;
    parse_command_line_into \%opts;     # Modifies @ARGV.
    $lrWorklist = make_worklist \@ARGV, true;

    #DEBUG
    #for my $hrItem (@$lrWorklist) {
    #    print %$hrItem,"\n";
    #    print ${$hrItem->{&WL_TEXT_REF}}, "\n";
    #}
    #print %opts, "\n";
    #print @ARGV, "\n";
    #exit #DEBUG

    # Set up for recursive glob: If it has been requested, stash the
    # provided pathspecs to try at each directory we visit.
    my @globs;
    @globs = @ARGV if $opts{&RECURSIVE_GLOB};

    # Do it, Rockapella!
    my @failures;   # which pathspecs we couldn't process
    if(process_worklist(\%opts, \@globs,    # second $lrWorklist is the result
                            $lrWorklist, $lrWorklist, \@failures)) {
        # Print the regular results

        # Sort however the user wanted
        sort_results \%opts, $lrWorklist;

        # Escape results if requested
        if($opts{&ESCAPE_OUTPUT}) {
            for my $hrWorklistItem (@$lrWorklist) {
                print STDERR "Checking ",
                    ${$hrWorklistItem->{&WL_TEXT_REF}}, "\n"
                    if DEBUG;
                next if $hrWorklistItem->{&WL_DO_NOT_PRINT};
                ${$hrWorklistItem->{&WL_TEXT_REF}} =
                    make_printable ${$hrWorklistItem->{&WL_TEXT_REF}};
                print STDERR "  escaped as ",
                    ${$hrWorklistItem->{&WL_TEXT_REF}}, "\n"
                    if DEBUG;
            }
        }

        # Dump the (possibly escaped) results
        my $sep = $opts{&OUTPUT_SEPAR};

        for my $hrWorklistItem (@$lrWorklist) {
            # skip ones we cleared
            next if $hrWorklistItem->{&WL_DO_NOT_PRINT};

            print "=> " if DEBUG;
            print ${$hrWorklistItem->{&WL_TEXT_REF}}, $sep;
        } # next $result
    } # endif any results

    # Report any errors
    if(@failures) {
        # Print all the errors, converting nonprintable characters to hex
        # escapes.  Errors are currently not sorted.
        print STDERR (
            join("\n", (map make_printable, @failures) ),
            "\n"
        );
        exit EXIT_FILE_ERR;
    } #endif @failures

    exit EXIT_OK;
} # main()

# === Worker routines ===================================================

sub process_worklist {
    my ($hrOpts, $lrGlobs, $lrProvidedWorklist, $lrOutputWorklist, $lrFailures,
        $subsid) = @_;
        # $subsid is undef the first time we are called, then
        # true after that.

    my $bHaveResults = false;   # whether there's a result to print
    my $lrWorklist = $lrProvidedWorklist;   # changes as we run
    my @addl;   # this will hold paths to be processed next.
                # Using @addl means we don't have to mutate a possibly-long
                # $lrWorklist.

    my $done = false;
    while(!$done) {
        print STDERR "**Iter\n" if DEBUG;
        @addl = ();     # always start fresh

        for my $hrWorklistItem (@$lrWorklist) {
            $bHaveResults ||=
                process_worklist_item($hrOpts, $hrWorklistItem, $lrFailures, \@addl);
            #push @{$lrFailures}, $path; # DEBUG
        } # foreach $path

        # If we are processing anything other than the output worklist,
        # tack the results onto that ever-growing list.  We do this in
        # case @ARGV is a long list from an xargs --- we don't want to
        # copy it, just in case.
        if($lrWorklist != $lrOutputWorklist) {
            print STDERR "Adding ", scalar @$lrWorklist, " to ",
                scalar @$lrOutputWorklist, " entries.\n" if DEBUG;
            push @$lrOutputWorklist, @$lrWorklist;
        }

        if(@addl) {     # set up for the next iteration
            print STDERR "Making worklist\n" if DEBUG;
            $lrWorklist = make_worklist \@addl;
            $done = false;
        } else {
            $done = true;
        }

    } # while !$done

    return $bHaveResults;
} # process_worklist()

sub process_worklist_item {
    my ($hrOpts, $hrWorklistItem, $lrFailures, $lrAddl, #bDontGlob
        ) = @_;

    # TODO finish implementing this
    #my $pathspec = $$srPathspec;
    #
    #if($hrOpts->{&DO_GLOB} && !bDontGlob) {
    #    my @results = bsd_glob($pathspec);
    #    if(!@results) {
    #        push @$lrFailures, "No files matched '" . make_printable $$srPathspec . "'.";
    #        return;
    #    } elsif(scalar @results > 1) {
    #        push @$lrAddl, @results;
    #       $$srPathspec=undef;     # Remove the glob (or something).
    #        return;                # Different for recursive glob.
    #    } else {
    #        $pathspec = $results[0];
    #            # If it was a single file, process it now.
    #            # TODO track whether pathspecs came from glob and don't
    #            # re-glob them?
    #    }
    #} # endif DO_GLOB

    # Process this pathspec, which should be a single directory entry

    my $item_text = ${$hrWorklistItem->{&WL_TEXT_REF}};
    my $fileinfo = stat($item_text);

    if(!$fileinfo) {
        push @$lrFailures, "Could not stat $item_text";
        return;
    }

    $hrWorklistItem->{&WL_STAT_REF} = \$fileinfo;   # stash for the output code
    my ($basename, $dirs) = fileparse($item_text);
        # Don't use splitpath(), which chokes on '.git/.'.

    print STDERR "Processing $item_text (basename  -$basename-, dir -$dirs-)\n"
        if DEBUG;

    if(S_ISDIR($fileinfo->mode)) {
        print STDERR "  is directory\n" if DEBUG;

        # Shorthand for the context
        my $all_dot = $hrOpts->{&ALL_DOT};
        my $most_dot = $hrOpts->{&MOST_DOT};
        my $recursive = $hrOpts->{&RECURSE};
        my $dash_d = $hrOpts->{&DIR_AS_DIR};    # dash_d => not recursive
        my $isTop = $hrWorklistItem->{&WL_IS_TOP};
            # "top-level" means it was specified on the command line.
        my $one_arg = $hrOpts->{&ONE_ARG};

        # Shorthand for special cases in the names
        my $isD = $basename eq '.';
        my $isDD = $basename eq '..';
        my $isDotfile = $basename =~ /^\./;

        print STDERR "  -a $all_dot -A $most_dot -d $dash_d -R $recursive ".
            "top $isTop one_arg $one_arg . $isD .. $isDD .* $isDotfile\n"
            if DEBUG;

        # Figure out what to do
        my $isWanted = (    # dotfile-based filtering
            (!$isDotfile) ||                    # not a dotfile
            ($isDotfile && $all_dot) ||         # keep dotfiles
            ($isDotfile && $most_dot && !$isDD) # keep except . and ..
        );

        # by default, just list it as a regular entry (if we want it)
        my $bShouldSuppress = !$isWanted;
        my $bShouldRecurse = false;

        if( $isTop && $one_arg ) {      # the only arg: descend into it
            $bShouldSuppress = true;    # and don't print.
            $bShouldRecurse = true;
        }

        elsif( $isTop ) {               # One of several top-level args:
            $bShouldSuppress = false;   # print, and descend unless -d.
            $bShouldRecurse = !$dash_d; # -R is irrelevant here.
        }

        elsif( $isWanted ) {            # A non-toplevel we want: recurse
            $bShouldRecurse =           # if requested, and not . or .. .
                $recursive && !($isD || $isDD);
        }   # Note -d trumps -R, so we don't have to test $dash_d.

        # --- Now that we've figured out what to do, go do it. ---
        if($bShouldSuppress) {
            print STDERR "    supressing\n" if DEBUG;
            wl_suppress $hrWorklistItem
        }

        if($bShouldRecurse) {
            print STDERR "    recursing\n" if DEBUG;
            my $dirh;
            if(!opendir($dirh, $item_text)) {
                push @$lrFailures, "Could not read directory $item_text";
            } else {
                push @$lrAddl,
                    (map { my $rv = catfile $item_text, $_;
                            print STDERR "    Added -$rv-\n" if DEBUG;
                            $rv } readdir($dirh));
                    # Also pushes . and .., which are ignored by the code above
                    # when we get to them in a later call.
            } #endif dir opened OK
        } # endif recursing

    } else {    # not a directory
        # Nothing to do here - the pathspec was a regular file, and we are
        # not currently stashing any information about it.
    } #endif is a directory else

    return !($hrWorklistItem->{&WL_DO_NOT_PRINT});
} # process_worklist_item()

sub sort_results {
} # sort_results()

# === Utility routines ==================================================
sub make_printable {
# Return a printable version (currently octal escapes) of the original string.
# TODO change this from hex escapes to cat -v format.
    my $in = $_[0] // $_;
    return $in =~ s/(\\|[^[:print:]])/'\\'.(sprintf "%03o", ord $1)/ger;
        # For hex, use s/.../'\x'.unpack('H*', $1)/ger per
        # http://perldoc.perl.org/perlpacktut.html#The-Basic-Principle
} # make_printable()

# === Worklist routines =================================================

sub wl_new {
    my $srText = shift or die "Can't create worklist item with no text";
    my %defaults =  (   &WL_IS_TOP => false,
                        &WL_IS_GLOB_RESULT => false,
                        &WL_DO_NOT_PRINT => false,
                    );
    my %flags = ( %defaults, @_ );  # parameters override defaults
        # Thanks to Fletch, http://www.perlmonks.org/?node_id=161104

    return +{   &WL_TEXT_REF => $srText,
                %flags
            };
} # wl_new()

sub wl_suppress {
    my $hrWorklistItem = shift;
    $hrWorklistItem->{&WL_DO_NOT_PRINT} = true;
} # wl_suppress()

# === Command line ======================================================

sub parse_command_line_into {
# Takes a reference to a hash into which the options will go.
# Exits on failure or if help text was printed.
# Modifies @ARGV, since the input command line may well be a long list from
# xargs, and we don't want to make an expensive copy.

    my $hrOptsOut = shift;

    # --- Parse the options ---
    Getopt::Long::Configure qw(gnu_getopt);

    # Set defaults so we don't have to test them with exists().
    $hrOptsOut->{&ALL_DOT} = false;
    $hrOptsOut->{&MOST_DOT} = false;
    $hrOptsOut->{&ESCAPE_OUTPUT} = false;
    $hrOptsOut->{&DIR_AS_DIR} = false;
    #No default for OUTPUT_SEPAR_IS_EOL since it's negatable.
    $hrOptsOut->{&DO_GLOB} = false;
    $hrOptsOut->{&RECURSE} = false;

    # Get options
    GetOptions($hrOptsOut,  # destination hash
        'help|?', 'man',
        ALL_DOT,
        MOST_DOT,
        ESCAPE_OUTPUT . ESCAPE_OUTPUT_GOPTS,
        DIR_AS_DIR,
        OUTPUT_SEPAR_IS_EOL . OUTPUT_SEPAR_IS_EOL_GOPTS,
        AT_FILE . AT_FILE_GOPTS,
        AT_FILE_NL . AT_FILE_NL_GOPTS,
        DO_GLOB,
        RECURSE,
        )
    or pod2usage(2);

    # Help, if requested
    pod2usage(1) if defined $hrOptsOut->{help};
    pod2usage(-verbose => 2) if defined $hrOptsOut->{man};

    # --- If we have no args, process the current dir. ---
    # TODO? Move this into process_worklist_item?  `ls -d` matches just '.'.
    if(!@ARGV) {
        # Push the contents of curdir() as if they had been listed on the
        # command line.  We can't just push curdir() without creating a
        # special case in the inner loop of process_worklist_item, so do
        # it here to avoid slowing down that routine.
        my $dirh;
        if(!opendir($dirh, curdir())) {
            print STDERR "Could not read directory ", curdir(), "\n";
            exit EXIT_PARAM_ERR;
        } else {
            my $direntry;
            while( defined($direntry=readdir($dirh)) ) {
                my ($basename) = fileparse($direntry);

                next unless (
                    substr($basename,0,1) ne '.' || # not a dotfile
                    $hrOptsOut->{&ALL_DOT} ||       # keep dotfiles
                    (   $hrOptsOut->{&MOST_DOT} &&  # keep except . and ..
                        $basename !~ RE_DOT_OR_DOTDOT
                    )
                );
                print STDERR "Adding $direntry\n" if DEBUG;

                push @ARGV, $direntry;
            } # next $direntry
        } # endif opened dir OK
    } # endif no args

    #print STDERR ("pathspecs=>",join("\n",@ARGV),"\n") if DEBUG;

    # --- Process implied options. ---
    # Note: have to use ampersand on &RECURSIVE_GLOB per
    # http://stackoverflow.com/a/96869/2877364 by
    # http://stackoverflow.com/users/3101/nohat

    # -d overrides -R
    if($hrOptsOut->{&DIR_AS_DIR}) {
        $hrOptsOut->{&RECURSIVE} = false;
    }

    # --rglob implies -R and --glob
    if($hrOptsOut->{&RECURSIVE_GLOB}) {
        if(!$hrOptsOut->{&DIR_AS_DIR}) {
            $hrOptsOut->{&RECURSIVE} = true;
            $hrOptsOut->{&DO_GLOB} = true;
        } else {
            print STDERR "Can't use --rglob and -d together\n";
            exit EXIT_PARAM_ERR;
        }
    } #endif --rglob

    # --- Set internal values based on the provided options ---

    # Output separator
    $hrOptsOut->{&OUTPUT_SEPAR} = TERM_NULL;     # by default
    $hrOptsOut->{&OUTPUT_SEPAR} = TERM_EOL       # if implied or requested
        if ($hrOptsOut->{&ESCAPE_OUTPUT} || $hrOptsOut->{&OUTPUT_SEPAR_IS_EOL});
    $hrOptsOut->{&OUTPUT_SEPAR} = TERM_NULL      # but --noeol always wins
        if (defined $hrOptsOut->{&OUTPUT_SEPAR_IS_EOL} &&
            !$hrOptsOut->{&OUTPUT_SEPAR_IS_EOL}) ;

    # How many args?
    $hrOptsOut->{&ONE_ARG} = (scalar @ARGV == 1);

    # Globbing
    if($hrOptsOut->{&RECURSIVE_GLOB} || $hrOptsOut->{&DO_GLOB}) {
        print STDERR "Globbing not yet implemented.\n";     # DEBUG
        exit EXIT_PARAM_ERR;
    }

} # parse_command_line_into()

sub make_worklist {
    my $lrStrings = shift;
    my $isTop = @_ ? shift : false;
    my @srStringRefs = \(@$lrStrings);
        # list of string refs to each element of the provided list
    my @worklist = map { wl_new $_, &WL_IS_TOP => $isTop } @srStringRefs;
    return \@worklist;
} # make_worklist()

__END__

# Usage
=head1 NAME

ls0 - List filenames, with each output null-terminated.

=head1 SYNOPSIS

ls0 [options] [--] [pathspecs]

=head1 OPTIONS

=over 4

=item B<-a>

Also list files beginning with a '.'

=item B<-A>

Also list files beginning with a '.', except for '.' and '..'

=item B<-b>, B<--escape>

Print octal escapes for special characters and backslashes.  Implies B<--eol>
(newline separators); also specify B<--noeol> if you still want null terminators.

=item B<-d>

List directories as directories; don't list their contents.  Overrides B<-R>.
Can't be used with B<--rglob>.

=item B<--eol> (disable with B<--noeol>)

Separate output entries with a platform-specific end-of-line sequence
rather than a NULL.  May be useful with B<-b> or B<--glob>.

=item B<< --from <argfile> >> (or B<< -@ <argfile> >>)

Read the pathspecs to be processed from B<argfile>.  Each pathspec should
be separated by a NULL terminator ('\0').  This is ls_0_, after all.

=item B<< --fromeol <argfile> >>

Read the pathspecs to be processed from B<argfile>.  Each pathspec should
be separated by a platform-specific end-of-line (C<\r>, C<\n>, or C<\r\n>).
If you use this, make sure B<argfile> doesn't list any filenames that include
end-of-lines.

=item B<--glob>

Expand the provided pathspecs using perl's File::Glob::bsd_glob.
This is provided for shells that don't glob, or don't glob as you expect.
Make sure to quote the arguments if necessary to prevent your shell from
globbing before ls0 sees them.

=item B<-R>

Visit subdirectories recursively.  No effect if B<-d> is specified.

=item B<--rglob>

Glob in ls0 rather than (or in addition to) in the shell.  Try to glob
the pathspecs given on the command line in each directory visited.
Implies B<-R> and B<--glob>.  Can't be used with B<-d>.

=back

=head1 DIFFERENCES BETWEEN GNU ls(1) and ls0(1)

=head2 New Features

=over 4

=item B<< --from <argfile> >>, B<< --fromeol <argfile> >>

Read input pathspecs from B<argfile>

=item B<--glob>

Glob in ls0 rather than (or in addition to) in the shell

=item B<--rglob>

Glob in ls0 rather than (or in addition to) in the shell, and glob in each
subdir

=back

=head2 Unsupported ls(1) Features

The following GNU ls(1) options are not supported by ls0:

=over 4

=item B<-1> (print single line)

No need for it; we're not printing lines.

=back

=head2 Differences in behaviour

None documented yet!

=head1 COPYRIGHT

Copyright (c) 2016 Chris White <http://www.devwrench.com>
CC-BY-SA 3.0

Inspired by https://stackoverflow.com/a/41168189/2877364 by
myself, https://stackoverflow.com/users/2877364/cxw .
Code based in part on http://stackoverflow.com/a/13999717/2877364 by
http://stackoverflow.com/users/1922919/turningtaxis
and on http://stackoverflow.com/a/3960071/2877364 by
http://stackoverflow.com/users/459338/ruel

=cut

# vi: set ts=4 sts=4 sw=4 et ai ff=unix fenc=utf8: #

