#!/usr/bin/env perl
# ls0: A "ls" replacement that null-terminates its output filenames.
# To see the output on the console, pipe it to cat -A.  Nulls show as ^@.

# Style note: Hungarian prefixes are used on scalars:
#   "hr" (hash ref), "lr" (list ref), "sr" (string ref), "nr" (numeric ref),
#   "b" (boolean), "s" (string)

# TODO? add an option to prune specific directories?
# TODO store more info with each path: name, BFS pass # or depth,
# whether glob result or not.

package Com::DevWrench::Ls0;

# === Code ==============================================================
exit main(@ARGV);   # Invoke

# --- Syntax ---
use strict;
use warnings;

use constant false => 0;
use constant true  => 1;

# --- Imports ---
use Getopt::Long;
use Pod::Usage;
use File::Spec::Functions;
use File::Basename;
use File::stat;
use Fcntl ':mode';
#use File::Glob ':bsd_glob';

# --- Constants ---
use constant DEBUG => 1;

use constant {          # shell exit codes
    EXIT_OK => 0,          # success
    EXIT_FILE_ERR => 1,    # couldn't access at least one file
    EXIT_PARAM_ERR => 2,   # couldn't understand the command line
};

use constant {          # record terminators
    TERM_NULL => "\0",
    TERM_EOL => "\n",   # which will be translated to CRLF if necessary.
};                      # per http://www.perlmonks.org/?node_id=890769

# --- Names of command-line arguments ---
use constant {  # *_GOPTS are additional parameters for Getopt::Long
    ALL_DOT => 'a',
    MOST_DOT => 'A',
    ESCAPE_OUTPUT => 'b', ESCAPE_OUTPUT_GOPTS => '|escape',
    DIR_AS_DIR => 'd',
    OUTPUT_SEPAR_IS_EOL => 'eol', OUTPUT_SEPAR_IS_EOL_GOPTS => '!',
    AT_FILE => 'from',          # file listing other inputs, NULL separated.
    AT_FILE_GOPTS => '=s@',     # Getopt options for AT_FILE
    AT_FILE_NL => 'fromeol',    # file, EOL separated (platform-specific)
    AT_FILE_NL_GOPTS => '=s@',  # Getopt options
    DO_GLOB => 'glob',
    RECURSE => 'R',
    RECURSIVE_GLOB => 'rglob',

    # Other options not specified on the command line, but included in the hash
    OUTPUT_SEPAR => 'output_separator',     # \n or \0
    DEPTH => 'depth',
};

# TODO RESUME HERE distinguish possibly globbable paths from the results of
# globs, which should not be re-globbed.
# TODO maybe carry the stat structure along with each pathspec?

# --- Forward declarations ---
sub process_pathspecs;
    # takes hrOpts, lrPathspecs, lrOutputs, and lrFailures.
    # Adds to lrOutputs any outputs and to lrFailures any error messages.
sub process_one_pathspec;
    # takes (hrOpts, srPathspec, lrFailures, lrAddl [, bDontGlob].
    # Adds to lrAddl any pathspecs needing processing.  This yields a breadth-
    # first search of the space.

sub sort_results;
    # takes hrOpts, lrResults

sub parse_command_line_into;    #takes and modifies hrOpts
sub make_printable;     # Returns a printable representation of the arg string

# === Main ==============================================================
sub main {
    my %opts;
    #print STDERR ("cmdline=>",join("|",@ARGV),"\n") if DEBUG;
    parse_command_line_into \%opts;     # Modifies @ARGV.
    #DEBUG
    #print %opts;
    #print "\n";
    #print @ARGV;
    #print "\n";
    #print "foo\0bar\0";

    # Set up for recursive glob: If it has been requested, stash the
    # provided pathspecs to try at each directory we visit.
    my @globs;
    @globs = @ARGV if $opts{&RECURSIVE_GLOB};

    # Do it, Rockapella!
    my @failures;   # which pathspecs we couldn't process
    process_pathspecs(\%opts, \@ARGV, \@ARGV, \@failures);
        # second \@ARGV is the result

    # Print the regular results, if any
    if(@ARGV) {
        # Sort however the user wanted
        sort_results \%opts, \@ARGV;

        # Escape results if requested
        if($opts{&ESCAPE_OUTPUT}) {
            for my $result (@ARGV) {
                next unless defined $result;
                $result = make_printable $result;
            }
        }

        # Dump the (possibly escaped) results
        my $sep = $opts{&OUTPUT_SEPAR};

        for my $result (@ARGV) {
            next unless defined $result;    # skip ones we cleared
            print "=> " if DEBUG;
            print $result, $sep;
        } # next $result
    } # endif any results

    # Report any errors
    if(@failures) {
        # Print all the errors, converting nonprintable characters to hex
        # escapes.  Errors are currently not sorted.
        print STDERR (
            join("\n", (map make_printable, @failures) ),
            "\n"
        );
        exit EXIT_FILE_ERR;
    } #endif @failures

    exit EXIT_OK;
} # main()

# === Worker routines ===================================================

sub process_pathspecs {
    my ($hrOpts, $lrPaths, $lrOutputs, $lrFailures) = @_;
    my @addl;   # this will hold paths to be processed next.
                # Using @addl means we don't have to mutate a possibly-long
                # @ARGV.

    for my $path (@$lrPaths) {
        process_one_pathspec $hrOpts, \$path, $lrFailures, \@addl;
        #push @{$lrFailures}, $path; # DEBUG
    } # foreach $path

    # If we are processing anything other than @ARGV, tack the results onto
    # the ever-growing @ARGV.  We do this in case @ARGV is a long list from
    # an xargs --- we don't want to copy it, just in case.
    if($lrPaths != $lrOutputs) {
        push @$lrOutputs, @$lrPaths;
    }

    if(@addl) {
        @_=($hrOpts, \@addl, $lrOutputs, $lrFailures);
        goto &process_pathspecs;    # tail recurse to process @addl
    }

} # process_pathspecs()

sub process_one_pathspec {
    my ($hrOpts, $srPathspec, $lrFailures, $lrAddl, #bDontGlob
        ) = @_;

    # TODO finish implementing this
    #my $pathspec = $$srPathspec;
    #
    #if($hrOpts->{&DO_GLOB} && !bDontGlob) {
    #    my @results = bsd_glob($pathspec);
    #    if(!@results) {
    #        push @$lrFailures, "No files matched '" . make_printable $$srPathspec . "'.";
    #        return;
    #    } elsif(scalar @results > 1) {
    #        push @$lrAddl, @results;
    #       $$srPathspec=undef;     # Remove the glob (or something).
    #        return;                # Different for recursive glob.
    #    } else {
    #        $pathspec = $results[0];
    #            # If it was a single file, process it now.
    #            # TODO track whether pathspecs came from glob and don't
    #            # re-glob them?
    #    }
    #} # endif DO_GLOB

    # Process this pathspec, which should be a single directory entry

    my $ps = $$srPathspec;
    my $fileinfo = stat($ps);
    if(!$fileinfo) {
        push @$lrFailures, "Could not stat $ps";
        return;
    }

    my ($basename, $dirs) = fileparse($ps);
        # Don't use splitpath(), which chokes on '.git/.'.

    print STDERR "Processing $ps (basename  -$basename-, dir -$dirs-)\n"
        if DEBUG;

    if(S_ISDIR($fileinfo->mode)) {
        # TODO RESUME HERE handle . and .. properly.  Don't recurse into
        # either; don't print either unless ALL_DOT.
        print STDERR "  is directory\n" if DEBUG;
        if($basename =~ /^\.{1,2}$/) {  # . and ..
            if(!$hrOpts->{&ALL_DOT}) {
                print STDERR "    clearing\n" if DEBUG;
                $$srPathspec = undef;   # Don't show . and .. unless -a
            }

        } else {    # not . or ..

            # Recurse into subdirectories if requested.
            # TODO on "ls0 foo" where ./foo is a directory, recurse in, and
            # don't list the actual dir that was mentioned on the command line
            if($hrOpts->{&RECURSE} ||               # -R
                (dirname($dirs) eq curdir()) ) {    # child of curdir
                print STDERR "  Recursing\n" if DEBUG;
                my $dirh;
                if(!opendir($dirh, $$srPathspec)) {
                    push @$lrFailures, "Could not read directory $$srPathspec";
                } else {
                    push @$lrAddl,
                        (map { my $rv = catfile $$srPathspec, $_;
                                print STDERR "    Added -$rv-\n" if DEBUG;
                                $rv } readdir($dirh));
                }
            } #endif RECURSE
        }
    } else {    # not a directory
        # Nothing to do here - the pathspec was a regular file, and we are
        # not currently stashing any information about it.
    } #endif is a directory else

} # process_one_pathspec()

sub sort_results {
} # sort_results()

sub make_printable {
# Return a printable version (currently octal escapes) of the original string.
# TODO change this from hex escapes to cat -v format.
    my $in = $_[0] // $_;
    return $in =~ s/(\\|[^[:print:]])/'\\'.(sprintf "%03o", ord $1)/ger;
        # For hex, use s/.../'\x'.unpack('H*', $1)/ger per
        # http://perldoc.perl.org/perlpacktut.html#The-Basic-Principle
} # make_printable()

# === Command line ======================================================

sub parse_command_line_into {
# Takes a reference to a hash into which the options will go.
# Exits on failure or if help text was printed.
# Modifies @ARGV, since the input command line may well be a long list from
# xargs, and we don't want to make an expensive copy.

    my $hrOptsOut = shift;

    Getopt::Long::Configure qw(gnu_getopt);

    GetOptions($hrOptsOut,  # destination hash
        'help|?', 'man',
        ALL_DOT,
        MOST_DOT,
        ESCAPE_OUTPUT . ESCAPE_OUTPUT_GOPTS,
        DIR_AS_DIR,
        OUTPUT_SEPAR_IS_EOL . OUTPUT_SEPAR_IS_EOL_GOPTS,
        AT_FILE . AT_FILE_GOPTS,
        AT_FILE_NL . AT_FILE_NL_GOPTS,
        DO_GLOB,
        RECURSE,
        )
    or pod2usage(2);

    # Help, if requested
    pod2usage(1) if defined $hrOptsOut->{help};
    pod2usage(-verbose => 2) if defined $hrOptsOut->{man};

    if(!@ARGV) {     # If we have no args, process the current dir
        my $dirh;
        if(!opendir($dirh, curdir())) {
            print STDERR "Could not read current directory";
            exit EXIT_FILE_ERR;
        } else {
            push @ARGV, readdir($dirh);
        }
    } # endif no args

    #print STDERR ("pathspecs=>",join("\n",@ARGV),"\n") if DEBUG;

    # Process implied options.
    # Note: have to use ampersand on &RECURSIVE_GLOB per
    # http://stackoverflow.com/a/96869/2877364 by
    # http://stackoverflow.com/users/3101/nohat
    if($hrOptsOut->{&RECURSIVE_GLOB}) {
        $hrOptsOut->{&RECURSIVE} = 1;
        $hrOptsOut->{&DO_GLOB} = 1;
    }

    # Set the output separator based on the provided options
    $hrOptsOut->{&OUTPUT_SEPAR} = TERM_NULL;     # by default
    $hrOptsOut->{&OUTPUT_SEPAR} = TERM_EOL       # if implied or requested
        if ($hrOptsOut->{&ESCAPE_OUTPUT} || $hrOptsOut->{&OUTPUT_SEPAR_IS_EOL});
    $hrOptsOut->{&OUTPUT_SEPAR} = TERM_NULL      # but --noeol always wins
        if (defined $hrOptsOut->{&OUTPUT_SEPAR_IS_EOL} &&
            !$hrOptsOut->{&OUTPUT_SEPAR_IS_EOL}) ;

    # DEBUG
    if($hrOptsOut->{&RECURSIVE_GLOB} || $hrOptsOut->{&DO_GLOB}) {
        print STDERR "Globbing not yet implemented.\n";
        exit EXIT_PARAM_ERR;
    }

} # parse_command_line_into()

__END__

# Usage
=head1 NAME

ls0 - List filenames, with each output null-terminated.

=head1 SYNOPSIS

ls0 [options] [--] [pathspecs]

=head1 OPTIONS

=over 4

=item B<-a>

Also list files beginning with a '.'

=item B<-A>

Also list files beginning with a '.', except for '.' and '..'

=item B<-b>, B<--escape>

Print octal escapes for special characters and backslashes.  Implies --eol
(newline separators); also specify --noeol if you still want null terminators.

=item B<-d>

List directories as directories; don't list their contents

=item B<--eol> (disable with B<--noeol>)

Separate output entries with a platform-specific end-of-line sequence
rather than a NULL.  May be useful with B<-b> or B<--glob>.

=item B<< --from <argfile> >>, B<< --fromeol <argfile> >>

Read the pathspecs to be processed from B<argfile>.  Each pathspec should
be separated by a NULL terminator ('\0').  This is ls_0_, after all.

=item B<< --fromeol <argfile> >>

Read the pathspecs to be processed from B<argfile>.  Each pathspec should
be separated by a platform-specific end-of-line (C<\r>, C<\n>, or C<\r\n>).
If you use this, make sure B<argfile> doesn't list any filenames that include
end-of-lines.

=item B<--glob>

Expand the provided pathspecs using perl's File::Glob::bsd_glob.
This is provided for shells that don't glob, or don't glob as you expect.
Make sure to quote the arguments if necessary to prevent your shell from
globbing before ls0 sees them.

=item B<-R>

Visit subdirectories recursively.

=item B<--rglob>

Glob in ls0 rather than (or in addition to) in the shell.  Try to glob
the pathspecs given on the command line in each directory visited.
Implies B<-R> and B<--glob>.
subdir

=back

=head1 DIFFERENCES BETWEEN GNU ls(1) and ls0(1)

=head2 New Features

=over 4

=item B<< --from <argfile> >>, B<< --fromeol <argfile> >>

Read input pathspecs from B<argfile>

=item B<--glob>

Glob in ls0 rather than (or in addition to) in the shell

=item B<--rglob>

Glob in ls0 rather than (or in addition to) in the shell, and glob in each
subdir

=back

=head2 Unsupported ls(1) Features

The following GNU ls(1) options are not supported by ls0:

=over 4

=item B<-1> (print single line)

No need for it; we're not printing lines.

=back

=head1 COPYRIGHT

Copyright (c) 2016 Chris White <http://www.devwrench.com>
CC-BY-SA 3.0

Inspired by https://stackoverflow.com/a/41168189/2877364 by
myself, https://stackoverflow.com/users/2877364/cxw .
Code based in part on http://stackoverflow.com/a/13999717/2877364 by
http://stackoverflow.com/users/1922919/turningtaxis
and on http://stackoverflow.com/a/3960071/2877364 by
http://stackoverflow.com/users/459338/ruel

=cut

# vi: set ts=4 sts=4 sw=4 et ai ff=unix fenc=utf8: #

