#!/usr/bin/env perl
# ls0: A "ls" replacement that null-terminates its output filenames.
# To see the output on the console, pipe it to cat -A.  Nulls show as ^@.

# Style note: Hungarian prefixes are used on scalars:
#   "hr" (hash ref), "lr" (list ref), "sr" (string ref), "nr" (numeric ref),
#   "b" or "is" (boolean), "s" (string), "wli" (Worklist_Item instance)

# TODO? add an option to prune specific directories?
# TODO store more info with each path: name, BFS pass # or depth,
# whether glob result or not.

package Com::DevWrench::Ls0;

# === Code ==============================================================
exit main();   # Invoke

# --- Syntax ---
use strict;
use warnings;

use constant { false => 0, true  => 1 };

# --- Imports ---
use Getopt::Long;
use Pod::Usage;
use File::Spec::Functions;
use File::Basename;
use File::stat;
use Fcntl ':mode';
#use File::Glob ':bsd_glob';

# --- Constants ---
use constant DEBUG => 1;

use constant {          # shell exit codes
    EXIT_OK => 0,          # success
    EXIT_FILE_ERR => 1,    # couldn't access at least one file
    EXIT_PARAM_ERR => 2,   # couldn't understand the command line
};

use constant {          # record terminators
    TERM_NULL => "\0",
    TERM_EOL => "\n",   # which will be translated to CRLF if necessary.
};                      # per http://www.perlmonks.org/?node_id=890769

# Regexes
use constant RE_DOT_OR_DOTDOT => qr/^\.{1,2}$/;

# --- Names of command-line arguments ---
use constant {  # *_GOPTS are additional parameters for Getopt::Long
    ALL_DOT => 'a',
    MOST_DOT => 'A',
    ESCAPE_OUTPUT => 'b', ESCAPE_OUTPUT_GOPTS => '|escape',
    DIR_AS_DIR => 'd',
    OUTPUT_SEPAR_IS_EOL => 'eol', OUTPUT_SEPAR_IS_EOL_GOPTS => '!',
    AT_FILE => 'from',          # file listing other inputs, NULL separated.
    AT_FILE_GOPTS => '|@=s@',   # Getopt options for AT_FILE
    AT_FILE_NL => 'fromeol',    # file, EOL separated (platform-specific)
    AT_FILE_NL_GOPTS => '=s@',  # Getopt options
    DO_GLOB => 'glob',
    LEAVES_ONLY => 'leaf',
    RECURSE => 'R',
    RECURSIVE_GLOB => 'rglob',

    # Other options not specified on the command line, but included in the hash
    OUTPUT_SEPAR => 'output_separator',     # \n or \0
    DEPTH => 'depth',
    ONE_ARG => 'one_arg',       # if only one arg provided
};

# TODO RESUME HERE distinguish possibly globbable paths from the results of
# globs, which should not be re-globbed.
# TODO maybe carry the stat structure along with each pathspec?

# --- Worklist Items ---
# What ls0 needs to do is defined by a worklist, a list of Worklist_Item refs.
# Each Worklist_Item includes text and various flags.

package Worklist_Item {
    use constant { false => 0, true  => 1 };    # constants are per-package
    use constant DEBUG => true;

    use fields qw(srtext top fromglob visible stat);

    sub new {   # ($self, $srText[, $bIsTop]) -> Worklist_Item
        my ($class, $srText, $isTop) = @_;

        my Worklist_Item $self = fields::new($class) unless ref $class;
        @$self{'top', 'fromglob', 'visible', 'stat'} =
            (false, false, true, undef);

        # Fill in from parameters
        $self->text($srText);
        if(defined $isTop) { $self->{top} = $isTop; }
        return $self;
    } #new()

    sub text {  # ($self[, $sText/srText]) -> string: setter if $sText provided
                # can take a string or a reference.
        my Worklist_Item $self = shift;
        if(@_) {
            my $arg = shift;
            if(ref($arg) eq "SCALAR") {
                $self->{srtext} = $arg;
            } else {
                $self->{srtext} = \$arg;
            }
        } #endif text provided
        return ${$self->{srtext}};  # always a getter
    } #text() setter/getter

    sub suppress {  # ($self) -> undef
        my Worklist_Item $self = shift;
        $self->{visible} = false;
    } #suppress() setter
} # Worklist_Item

# --- Forward declarations ---
sub process_worklist;
    # takes hrOpts, lrGlobs, lrWorklist, lrOutputWorklist, and lrFailures.
    # Adds to lrOutputWorklist any outputs.  Adds to lrFailures any
    # string error messages.  May modify @$lrWorklist.
    # Returns a bool indicating whether at least one worklist item
    # is to be printed as a result.
sub process_worklist_item;
    # takes (hrOpts, lrGlobs, wli, lrFailures, lrAddl [, bDontGlob].
    # Adds to lrAddl any pathspecs needing processing.  This yields a breadth-
    # first search of the space.  May modify $wli.
    # Returns a bool indicating whether the worklist item is visible.

sub sort_results;
    # takes hrOpts, lrWorklist

sub parse_command_line_into;    # takes and modifies hrOpts; modifies @ARGV
sub make_worklist;              # takes lrStrings, bIsTop; returns lrWorklist.

# Utility routines
sub make_printable;     # Returns a printable representation of the arg string

# === Main ==============================================================
sub main {
    my %opts;           # everything that controls the behaviour of ls0
    my $lrWorklist;     # what we are being asked to process

    #print STDERR ("cmdline=>",join("|",@ARGV),"\n") if DEBUG;
    parse_command_line_into \%opts;     # Modifies @ARGV.
    $lrWorklist = make_worklist \@ARGV, true;

    #DEBUG
    #for my $hrItem (@$lrWorklist) {
    #    print %$hrItem,"\n";
    #    print ${$hrItem->{&WL_TEXT_REF}}, "\n";
    #}
    #print %opts, "\n";
    #print @ARGV, "\n";
    #exit #DEBUG

    # Set up for recursive glob: If it has been requested, stash the
    # provided pathspecs to try at each directory we visit.
    my @globs;
    @globs = @ARGV if $opts{&RECURSIVE_GLOB};

    # Do it, Rockapella!
    my @failures;   # which pathspecs we couldn't process
    if(process_worklist(\%opts, \@globs,    # second $lrWorklist is the result
                            $lrWorklist, $lrWorklist, \@failures)) {
        # Print the regular results

        # Sort however the user wanted
        sort_results \%opts, $lrWorklist;

        # Escape results if requested
        if($opts{&ESCAPE_OUTPUT}) {
            for my Worklist_Item $wli (@$lrWorklist) {
                #print STDERR "Checking ", $wli->text, "\n" if DEBUG;
                next if !$wli->{visible};
                $wli->text(make_printable ($wli->text =~ s|^./||r));
                #print STDERR "  escaped as ", $wli->text, "\n" if DEBUG;
            } #foreach wli
        } #endif escape

        # Dump the (possibly escaped) results
        my $sep = $opts{&OUTPUT_SEPAR};

        for my Worklist_Item $wli (@$lrWorklist) {
            # skip ones we cleared
            next unless $wli->{visible};

            print "=> " if DEBUG;
            print $wli->text, $sep;
        } # next $result
    } # endif any results

    # Report any errors
    if(@failures) {
        # Print all the errors, converting nonprintable characters to hex
        # escapes.  Errors are currently not sorted.
        print STDERR (
            join("\n", (map make_printable, @failures) ),
            "\n"
        );
        exit EXIT_FILE_ERR;
    } #endif @failures

    exit EXIT_OK;
} # main()

# === Worker routines ===================================================

sub process_worklist {
    my ($hrOpts, $lrGlobs, $lrProvidedWorklist, $lrOutputWorklist, $lrFailures,
        $subsid) = @_;
        # $subsid is undef the first time we are called, then
        # true after that.

    my $bHaveResults = false;   # whether there's a result to print
    my $lrWorklist = $lrProvidedWorklist;   # changes as we run
    my @addl;   # this will hold paths to be processed next.
                # Using @addl means we don't have to mutate a possibly-long
                # $lrWorklist.

    my $done = false;
    while(!$done) {
        print STDERR "**Iter (" . scalar @$lrWorklist . " items)\n" if DEBUG;
        @addl = ();     # always start fresh

        for my Worklist_Item $wli (@$lrWorklist) {
            my $vis =
                process_worklist_item($hrOpts, $wli, $lrFailures, \@addl);
            $bHaveResults ||= $vis;
                # Can't do $bHR ||= process_item() because ||= short-circuits
            #push @{$lrFailures}, $path; # DEBUG
        } # foreach $path

        # If we are processing anything other than the output worklist,
        # tack the results onto that ever-growing list.  We do this in
        # case @ARGV is a long list from an xargs --- we don't want to
        # copy it, just in case.
        if($lrWorklist != $lrOutputWorklist) {
            print STDERR "Adding ", scalar @$lrWorklist, " to ",
                scalar @$lrOutputWorklist, " entries.\n" if DEBUG;
            push @$lrOutputWorklist, @$lrWorklist;
        }

        if(@addl) {     # set up for the next iteration
            $lrWorklist = make_worklist \@addl;
            print STDERR "Made worklist of " . scalar @addl . " items\n"
                if DEBUG;
            $done = false;
        } else {
            $done = true;
        }

    } # while !$done

    return $bHaveResults;
} # process_worklist()

sub process_worklist_item {
    my ($hrOpts, $wli, $lrFailures, $lrAddl, #bDontGlob
        ) = @_;

    # TODO implement globs
    #my $pathspec = $$srPathspec;
    #
    #if($hrOpts->{&DO_GLOB} && !bDontGlob) {
    #    my @results = bsd_glob($pathspec);
    #    if(!@results) {
    #        push @$lrFailures, "No files matched '" . make_printable $$srPathspec . "'.";
    #        return;
    #    } elsif(scalar @results > 1) {
    #        push @$lrAddl, @results;
    #       $$srPathspec=undef;     # Remove the glob (or something).
    #        return;                # Different for recursive glob.
    #    } else {
    #        $pathspec = $results[0];
    #            # If it was a single file, process it now.
    #            # TODO track whether pathspecs came from glob and don't
    #            # re-glob them?
    #    }
    #} # endif DO_GLOB

    # Process this worklist item, which represents a single directory entry

    my $item_text = $wli->text;
    my $fileinfo = stat($item_text);

    if(!$fileinfo) {
        push @$lrFailures, "Could not stat $item_text";
        return;
    }

    $wli->{stat} = \$fileinfo;  # stash for use by the output code
    my ($basename, $dirs) = fileparse($item_text);
        # Don't use splitpath(), which chokes on '.git/.'.

    print STDERR "Processing $item_text (basename  -$basename-, dir -$dirs-)\n"
        if DEBUG;

    # Shorthand for the context
    my $all_dot = $hrOpts->{&ALL_DOT};
    my $most_dot = $hrOpts->{&MOST_DOT};
    my $recursive = $hrOpts->{&RECURSE};
    my $dash_d = $hrOpts->{&DIR_AS_DIR};    # dash_d => not recursive
    my $isTop = $wli->{top};
        # "top-level" means it was specified on the command line.
    my $one_arg = $hrOpts->{&ONE_ARG};

    # Shorthand for special cases in the names
    my $isD = $basename eq '.';
    my $isDD = $basename eq '..';
    my $isDotfile = $basename =~ /^\./;

    my $isWanted = (    # dotfile-based filtering
        (!$isDotfile) ||                    # not a dotfile
        ($all_dot) ||                       # -a: keep dotfiles
        ($most_dot && !($isD || $isDD))     # -A: keep except . and ..
    );

    print STDERR "  -a $all_dot  -A $most_dot  -d $dash_d  -R $recursive ".
        "top $isTop  one_arg $one_arg  . $isD  .. $isDD  .* $isDotfile\n"
        if DEBUG;

    if(S_ISDIR($fileinfo->mode)) {
        print STDERR "  is directory\n" if DEBUG;

        # Figure out what to do

        my $bShouldSuppress = !$isWanted;   # by default, just list it as a
        my $bShouldDescend = false;         # regular entry (if we want it)

        # A top-level arg:
        #   Print it unless only one was given (e.g., for "ls ..")
        #   Descend unless -d.  -R is irrelevant because we descend by default.
        if( $isTop ) {
            $bShouldSuppress = $one_arg;
            $bShouldDescend = !$dash_d;
        }

        elsif( $isWanted ) {            # A non-toplevel we want: recurse
            $bShouldDescend =           # if requested, and not . or .. .
                $recursive && !($isD || $isDD);
        }   # Note -d trumps -R, so we don't have to test $dash_d.

        # --- Now that we've figured out what to do, go do it. ---
        if($bShouldSuppress) {
            print STDERR "    suppressing\n" if DEBUG;
            $wli->suppress;
        }

        if($bShouldDescend) {
            print STDERR "    recursing\n" if DEBUG;
            my $dirh;
            if(!opendir($dirh, $item_text)) {
                push @$lrFailures, "Could not read directory $item_text";
            } else {
                push @$lrAddl,
                    (map { my $rv = catfile $item_text, $_;
                            print STDERR "    Added -$rv-\n" if DEBUG;
                            $rv } readdir($dirh));
                    # Also pushes . and .., which are ignored by the code above
                    # when we get to them in a later call.
            } #endif dir opened OK
        } # endif recursing

    } else {    # not a directory - treat files, pipes, links, &c. all as files
        print STDERR "  is file\n" if DEBUG;
        if(!$isWanted) {        # Drop dotfiles unless requested
            print STDERR "    suppressing\n" if DEBUG;
            $wli->suppress;
        }
    } #endif is a directory else

    return $wli->{visible};
} # process_worklist_item()

sub sort_results {
    # TODO implement this
} # sort_results()

# === Utility routines ==================================================
sub make_printable {
# Return a printable version (octal escapes) of the original string.
    my $in = $_[0] // $_;
    return $in =~ s/(\\|[^[:print:]])/'\\'.(sprintf "%03o", ord $1)/ger;
        # For hex, use s/.../'\x'.unpack('H*', $1)/ger per
        # http://perldoc.perl.org/perlpacktut.html#The-Basic-Principle
} # make_printable()

# === Command line ======================================================

sub parse_command_line_into {
# Takes a reference to a hash into which the options will go.
# Exits on failure or if help text was printed.
# Modifies @ARGV, since the input command line may well be a long list from
# xargs, and we don't want to make an expensive copy.

    my $hrOptsOut = shift;

    # --- Parse the options ---
    Getopt::Long::Configure qw(gnu_getopt);

    # Set defaults so we don't have to test them with exists().
    $hrOptsOut->{&ALL_DOT} = false;
    $hrOptsOut->{&MOST_DOT} = false;
    $hrOptsOut->{&ESCAPE_OUTPUT} = false;
    $hrOptsOut->{&DIR_AS_DIR} = false;
    #No default for OUTPUT_SEPAR_IS_EOL since it's negatable.
    $hrOptsOut->{&DO_GLOB} = false;
    $hrOptsOut->{&LEAVES_ONLY} = false;
    $hrOptsOut->{&RECURSE} = false;

    # Get options
    GetOptions($hrOptsOut,  # destination hash
        'help|?', 'man',
        ALL_DOT,
        MOST_DOT,
        ESCAPE_OUTPUT . ESCAPE_OUTPUT_GOPTS,
        DIR_AS_DIR,
        OUTPUT_SEPAR_IS_EOL . OUTPUT_SEPAR_IS_EOL_GOPTS,
        AT_FILE . AT_FILE_GOPTS,
        AT_FILE_NL . AT_FILE_NL_GOPTS,
        DO_GLOB,
        LEAVES_ONLY,
        RECURSE,
        )
    or pod2usage(2);

    # Help, if requested
    pod2usage(1) if defined $hrOptsOut->{help};
    pod2usage(-verbose => 2) if defined $hrOptsOut->{man};

    # --- If we have no args, process the current dir. ---
    # TODO? Move this into process_worklist_item?  `ls -d` matches just '.'.
    if(!@ARGV) {
        # Push the contents of curdir() as if they had been listed on the
        # command line.  We can't just push curdir() without creating a
        # special case in the inner loop of process_worklist_item, so do
        # it here to avoid slowing down that routine.
#        my $dirh;
#        if(!opendir($dirh, curdir())) {
#            print STDERR "Could not read directory ", curdir(), "\n";
#            exit EXIT_PARAM_ERR;
#        } else {
#            my $direntry;
#            while( defined($direntry=readdir($dirh)) ) {
#                my ($basename) = fileparse($direntry);
#
#                next unless (
#                    substr($basename,0,1) ne '.' || # not a dotfile
#                    $hrOptsOut->{&ALL_DOT} ||       # keep dotfiles
#                    (   $hrOptsOut->{&MOST_DOT} &&  # keep except . and ..
#                        $basename !~ RE_DOT_OR_DOTDOT
#                    )
#                );
#                print STDERR "Init: Adding $direntry\n" if DEBUG;
#
#                push @ARGV, $direntry;
#            } # next $direntry
#        } # endif opened dir OK
        push @ARGV, curdir();
    } # endif no args

    #print STDERR ("pathspecs=>",join("\n",@ARGV),"\n") if DEBUG;

    # --- Process implied options. ---
    # Note: have to use ampersand on &RECURSIVE_GLOB per
    # http://stackoverflow.com/a/96869/2877364 by
    # http://stackoverflow.com/users/3101/nohat

    # -d overrides -R
    if($hrOptsOut->{&DIR_AS_DIR}) {
        $hrOptsOut->{&RECURSE} = false;
    }

    # --rglob implies -R and --glob
    if($hrOptsOut->{&RECURSIVE_GLOB}) {
        if(!$hrOptsOut->{&DIR_AS_DIR}) {
            $hrOptsOut->{&RECURSE} = true;
            $hrOptsOut->{&DO_GLOB} = true;
        } else {
            print STDERR "Can't use --rglob and -d together\n";
            exit EXIT_PARAM_ERR;
        }
    } #endif --rglob

    # --- Set internal values based on the provided options ---

    # Output separator
    $hrOptsOut->{&OUTPUT_SEPAR} = TERM_NULL;     # by default
    $hrOptsOut->{&OUTPUT_SEPAR} = TERM_EOL       # if implied or requested
        if ($hrOptsOut->{&ESCAPE_OUTPUT} || $hrOptsOut->{&OUTPUT_SEPAR_IS_EOL});
    $hrOptsOut->{&OUTPUT_SEPAR} = TERM_NULL      # but --noeol always wins
        if (defined $hrOptsOut->{&OUTPUT_SEPAR_IS_EOL} &&
            !$hrOptsOut->{&OUTPUT_SEPAR_IS_EOL}) ;

    # How many args?  This is a special case: don't print the arg name
    # if it was the only arg and was a directory.
    $hrOptsOut->{&ONE_ARG} = (scalar @ARGV == 1);

    # Globbing
    if($hrOptsOut->{&RECURSIVE_GLOB} || $hrOptsOut->{&DO_GLOB}) {
        print STDERR "Globbing not yet implemented.\n";     # DEBUG
        exit EXIT_PARAM_ERR;
    }

    # DEBUG
    if($hrOptsOut->{&LEAVES_ONLY}) {
        print STDERR "--leaf not yet implemented.\n";     # DEBUG
        exit EXIT_PARAM_ERR;
    }

} # parse_command_line_into()

sub make_worklist {
    my $lrStrings = shift;
    my $isTop = @_ ? shift : false;
    my @srStringRefs = \(@$lrStrings);
        # list of string refs to each element of the provided list

    my @worklist = map { Worklist_Item::->new($_, $isTop) } @srStringRefs;
    return \@worklist;
} # make_worklist()

__END__

# Usage
=head1 NAME

ls0 - List filenames, with each output null-terminated.

=head1 SYNOPSIS

ls0 [options] [--] [pathspecs]

(Run ls0 --help for options, or ls0 --man for full documentation)

=head1 OPTIONS

=over 4

=item B<-a>

Also list files beginning with a '.'

=item B<-A>

Also list files beginning with a '.', except for '.' and '..'

=item B<-b>, B<--escape>

Print octal escapes for special characters and backslashes.  Implies B<--eol>
(newline separators); also specify B<--noeol> if you still want null terminators.

=item B<-d>

List directories as directories; don't list their contents.  Overrides B<-R>.
Can't be used with B<--rglob>.

=item B<--eol> (disable with B<--noeol>)

Separate output entries with a platform-specific end-of-line sequence
rather than a NULL.  May be useful with B<-b> or B<--glob>.

=item B<< --from <argfile> >> (or B<< -@ <argfile> >>)

Read the pathspecs to be processed from B<argfile>.  Each pathspec should
be separated by a NULL terminator ('\0').  This is ls_0_, after all.

=item B<< --fromeol <argfile> >>

Read the pathspecs to be processed from B<argfile>.  Each pathspec should
be separated by a platform-specific end-of-line (C<\r>, C<\n>, or C<\r\n>).
If you use this, make sure B<argfile> doesn't list any filenames that include
end-of-lines.

=item B<--glob>

Expand the provided pathspecs using perl's File::Glob::bsd_glob.
This is provided for shells that don't glob, or don't glob as you expect.
Make sure to quote the arguments if necessary to prevent your shell from
globbing before ls0 sees them.

=item B<--leaf>

Only list leaves, i.e., files plus directories for which no lower-level files
are being listed.

=item B<-R>

Visit subdirectories recursively.  No effect if B<-d> is specified.

=item B<--rglob>

Glob in ls0 rather than (or in addition to) in the shell.  Try to glob
the pathspecs given on the command line in each directory visited.
Implies B<-R> and B<--glob>.  Can't be used with B<-d>.

=back

=head1 DIFFERENCES BETWEEN GNU ls(1) and ls0(1)

=head2 New Features

=over 4

=item B<< --from <argfile> >>, B<< --fromeol <argfile> >>

Read input pathspecs from B<argfile>

=item B<--glob>

Glob in ls0 rather than (or in addition to) in the shell

=item B<--rglob>

Glob in ls0 rather than (or in addition to) in the shell, and glob in each
subdir

=item B<--leaf>

Only list leaves.

=back

=head2 Unsupported ls(1) Features

The following GNU ls(1) options are not supported by ls0:

=over 4

=item B<-1> (print single line)

No need for it; we're not printing lines.  Our B<-b> implies one line per file.

=back

=head2 Differences in behaviour

=head3 Output format for multiple subdirectories

When listing multiple directories, e.g., C<ls foo/ bar/>, ls(1) shows:

    foo:
    file_in_foo

    bar:
    file_in_bar

However, ls0(1) is intended for machine output, so it produces:

    foo
    bar
    foo/file_in_foo
    bar/file_in_bar

(in whatever order you have specified by the sort options).

=head1 COPYRIGHT

Copyright (c) 2016 Chris White <http://www.devwrench.com>
CC-BY-SA 3.0

Inspired by https://stackoverflow.com/a/41168189/2877364 by
myself, https://stackoverflow.com/users/2877364/cxw .
Code based in part on http://stackoverflow.com/a/13999717/2877364 by
http://stackoverflow.com/users/1922919/turningtaxis
and on http://stackoverflow.com/a/3960071/2877364 by
http://stackoverflow.com/users/459338/ruel

=cut

# vi: set ts=4 sts=4 sw=4 et ai ff=unix fenc=utf8: #

